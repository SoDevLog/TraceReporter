/****************************************************/
/*               CLOVER SECURED LAYER				*/
/*				Ineo-Sense Copyright 2014			*/
/****************************************************/
/****************************************************/
/*  Name: clthreadutils.c                			*/
/*													*/
/*  Created on: 26 juin 2014						*/
/*      Author: fdespres							*/
/****************************************************/
/* Description : routines to handle threads in CSL  */
/*													*/
/****************************************************/

/*--------------------------------------------------------------------------*\
 * We are managing to lists of Tuples : pReader->p_TplList2Send
 * and pReader->p_TplList2Read. This because at the and of the Write Cycle
 * We need to be able to recapitulate all what happend to send Tuples
 * to upper layer
\*--------------------------------------------------------------------------*/

#include "..\csl.h"
#include "..\inc\clthread.h"
#include "..\inc\generic.h"
#include "..\inc\cltuple.h"
#include "..\inc\clreaders.h"
#include "..\inc\otaservice.h"
#include "..\inc\clhelpers.h"
#include "pthread.h" // TODO : this is not portable

#define TOTO
#define TATA
#define NOT_TUTU

#include <stdio.h>
#include <ctype.h>

#define _DEBUG_PRINTF

/*--------------------------------------------------------------------------*/

pthread_mutex_t g_MutexReadIncomingWriteRead = PTHREAD_MUTEX_INITIALIZER;

/*--------------------------------------------------------------------------*/

#define READ_INCOMING

#define DEBUG_READ_INCOMING
#ifdef DEBUG_READ_INCOMING
#define DEBUG_PRINTF_READ_INCOMING DEBUG_PRINTF
#else
#define NO_DEBUG_PRINTF_READ_INCOMING
#endif

/*--------------------------------------------------------------------------*/
/* To reuse this mode see SESSION_MODE_CANCELED
 */
#define USE_MUTEX

#ifdef USE_MUTEX

#define MUTEX_INCOMING_READ_LOCK(msg) 		DEBUG_PRINTF("xxxx_MUTEX %s: %s LOCK", pReader->tCOMParams.aucPortName, msg);\
											pthread_mutex_lock(&pReader->tSync.mutexReadIncomingWR);

#define MUTEX_INCOMING_READ_UNLOCK(msg) 	DEBUG_PRINTF("xxxx_MUTEX %s: %s UNLOCK", pReader->tCOMParams.aucPortName, msg);\
											pthread_mutex_unlock(&pReader->tSync.mutexReadIncomingWR);

#else
#define MUTEX_INCOMING_READ_LOCK
#define MUTEX_INCOMING_READ_UNLOCK
#endif

/*--------------------------------------------------------------------------*\
 * Helper function to send ACK "06"
\*--------------------------------------------------------------------------*/
static e_Result SendDataToReader( t_Reader *pReader, clu8 *aBufferToSend, clu32 aBufferSize  )
{
	t_clContext *pCtxt = CL_NULL;
    e_Result 	status = CL_ERROR;
    t_Buffer    *pBuffForNet = CL_NULL;
	t_Tuple     *pTuple2Send = CL_NULL;

	// get context to have access to function pointers for memory/thread management on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return CL_ERROR;

	if ( pReader->eState == STATE_CONNECT )
	{
		if ( aBufferSize %2 != 0 )
			return CL_ERROR;

		clu32 dataToSendLenght = aBufferSize/2;
		clu8 dataToSend[ dataToSendLenght ];
		ConvertASCIToHex(aBufferToSend, aBufferSize, dataToSend, &dataToSendLenght);

		// Allocate buffer for data to send
		csl_pmalloc( (clvoid **)&pBuffForNet, sizeof(t_Buffer) );
		csl_pmalloc( (clvoid **)&pBuffForNet->pData, dataToSendLenght);

		// Allocate tuple which holds the data
		if ( CL_FAILED( csl_pmalloc( (clvoid **)&pTuple2Send, sizeof(t_Tuple)))) return CL_ERROR;

		// Save data into the buffer
		memcpy( pBuffForNet->pData, dataToSend, dataToSendLenght );

		// initialize a tuple default flags with memory
		if ( CL_SUCCESS( cl_initTuple( pTuple2Send, pBuffForNet, &pBuffForNet->pData, dataToSendLenght ) ) )
		{
			//
			// Insert new Tuple at the end of p_TplList2Send
			//
			t_Tuple *tuple2Send = pReader->p_TplList2Send;
			if ( tuple2Send != CL_NULL )
			{
				while ( tuple2Send->pNext != CL_NULL )
				{
					tuple2Send = tuple2Send->pNext;
				};
				tuple2Send->pNext = pTuple2Send;
			}
			else
			{
				pReader->p_TplList2Send = pTuple2Send;
			}

			//
			// Set tuple2Send on the next to send
			//
			tuple2Send = pReader->p_TplList2Send;
			while ( tuple2Send->pNext != CL_NULL )
			{
				tuple2Send = tuple2Send->pNext;
			};

			status = pReader->tReaderHalFuncs.fnIOSendData( pReader, tuple2Send->ptBuf );
		}
	}

	return status;
}

/*--------------------------------------------------------------------------*/

static bool g_TimeOut = false;

/*--------------------------------------------------------------------------*\
 *
\*--------------------------------------------------------------------------*/
e_Result clReaderWriteThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt 		= CL_NULL;
	e_Result 		status 		= CL_ERROR;
	t_Reader 		*pReader 	= CL_NULL;
	e_State			 eState;
	clu8			cancel		= 1; // bidon
	t_Tuple			*pLocalTupleList	= CL_NULL;
	t_Tuple			*pTuple2Send = CL_NULL;

	if ( CL_FAILED( status = cl_GetContext( &pCtxt ) ) )
		return CL_ERROR;

	pReader = pCallingReader;

	DEBUG_PRINTF("clReaderWriteThread: DoBEGIN");

	do
	{
		pCtxt->ptHalFuncs->fnDestroyThreadAsked( &cancel );

		if ( pReader == CL_NULL )
		{
			DEBUG_PRINTF("clReaderWriteThread: READER_IS_NULL");
			continue; // return waiting for cancellation
		}

		//
		// Wait for a connected reader
		//
		cl_ReaderGetState( pReader, &eState );
		if ( eState != STATE_CONNECT )
		{
			DEBUG_PRINTF1("clReaderWriteThread_%s: READER_NOT_CONNECTED", pReader->tCOMParams.aucPortName);
			pCtxt->ptHalFuncs->fnWaitMs( 1000 );

			continue; // return waiting for cancellation
		}

//		status = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4Write, 5000 );
		sem_wait( pReader->tSync.pSgl4Write ); // TODO: implement sem_wait in CSL

		DEBUG_PRINTF("clReaderWriteThread_%s: WRITE", pReader->tCOMParams.aucPortName);

		//
		// Send tuple to IO PortCOM
		//
		// TODO: Find why UI layer can release pSgl4Write with p_TplList2Send == NULL
		if ( pReader->p_TplList2Send == CL_NULL )
		{
			continue; // return waiting for another pSgl4Write
		}
		pLocalTupleList	= pReader->p_TplList2Send;
		status = pReader->tReaderHalFuncs.fnIOSendData( pReader, pLocalTupleList->ptBuf );

		//
		// Give Tuples to upper layer and free memory
		//
		pTuple2Send = pReader->p_TplList2Send;
		while ( pTuple2Send != NULL )
		{
			pReader->tCallBacks.fnIOSendDataDone_cb( pReader, pTuple2Send, status );

			t_Tuple *pTupleNext = (t_Tuple *)pTuple2Send->pNext;
			pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send->ptBuf->pData );
			pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send->ptBuf );
			pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send );
			pTuple2Send = pTupleNext;
		}
		pReader->p_TplList2Send = CL_NULL;

		//
		// Tell to the ReadThread that it can Read Tuples
		//
		pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read);

		//
		// Wait for the ReadThread to End
		//
		status = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4ReadComplete, 3000 );
		if ( status == CL_TIMEOUT_ERR )
		{
			DEBUG_PRINTF("clReaderWriteThread_%s: WRITE_COMPLETE: ERROR", pReader->tCOMParams.aucPortName);
		}
		else
		{
			DEBUG_PRINTF("clReaderWriteThread_%s: WRITE_COMPLETE: OK", pReader->tCOMParams.aucPortName);
		}

		//
		// Tell upper layer that cycle is finished
		//
		pCtxt->ptHalFuncs->fnSemaphoreRelease( pReader->tSync.pSgl4WriteComplete );
	}
	while ( 1 );
}

/*--------------------------------------------------------------------------*/

e_Result clReaderReadThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt 				= CL_NULL;
	e_Result 		 status_cl 			= CL_ERROR;
	e_Result 		 status_read 		= CL_ERROR;
	t_Reader 		*pReader = CL_NULL;
	e_State			 eState;
	clu8			 cancel	=	1;
	t_Tuple			*pTuple2ReadIncoming = CL_NULL;
    clu32 			 nbTupleIncoming  = 0;
    clu32 			 response_received  = 0;

    clu8 			bufferACK[2] = "06";

	if ( CL_FAILED( status_cl = cl_GetContext( &pCtxt ) ) )
		return CL_ERROR;

	pReader = pCallingReader;

	DEBUG_PRINTF("clReaderReadThread: DoBEGIN");

	do
	{
		pCtxt->ptHalFuncs->fnDestroyThreadAsked( &cancel );

		if ( pReader == CL_NULL )
		{
			DEBUG_PRINTF("clReaderReadThread: READER_IS_NULL");
			continue; // return waiting for cancellation
		}

		//
		// Wait for a connected reader
		//
		cl_ReaderGetState( pReader, &eState );
		if ( eState != STATE_CONNECT )
		{
			DEBUG_PRINTF1("clReaderReadThread_%s: READER_NOT_CONNECTED", pReader->tCOMParams.aucPortName);
			pCtxt->ptHalFuncs->fnWaitMs( 1000 );

			continue; // return waiting for cancellation
		}

		//
		// Wait for signal to read otherwise read spontaneously
		//
		status_read = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4Read, 100 ); // 300 // 350 // 500 // 1000 / 5000 if nothing to be read

		//
		// There is no Write Request, so lets try to read something incoming
		//
		DEBUG_PRINTF1("clReaderReadThread_%s: READ", pReader->tCOMParams.aucPortName);

		nbTupleIncoming = 0;
		response_received = 0;

		status_read = pReader->tReaderHalFuncs.fnIOGetData( pReader,  &pReader->p_TplList2Read );
		if ( status_read == CL_OK )
		{
			DEBUG_PRINTF("clReaderReadThread_%s: OK", pReader->tCOMParams.aucPortName );

			pTuple2ReadIncoming = pReader->p_TplList2Read;
			while ( pTuple2ReadIncoming != NULL )
			{
				// Count how many tuples are received
				nbTupleIncoming += 1;

				// BRY_01102015
//				if ( pTuple2ReadIncoming->ptBuf->pData[0] !=  0x06 )
//				{
//					DEBUG_PRINTF("clReaderReadThread_%s: RESPONSE_RECEIVED", pReader->tCOMParams.aucPortName );
//					response_received = 1;
//				}

				pTuple2ReadIncoming = pTuple2ReadIncoming->pNext;
			}

			DEBUG_PRINTF_READ_INCOMING("clReaderReadThread_%s: IOGetData: Incoming [%d]", pReader->tCOMParams.aucPortName, nbTupleIncoming);

			if ( nbTupleIncoming >= 1 )
			{
				//
				// Give Tuples to upper layer
				//
				pTuple2ReadIncoming = pReader->p_TplList2Read;
				while ( pTuple2ReadIncoming != NULL )
				{
					pReader->tCallBacks.fnIOData2Read_cb( pReader, pTuple2ReadIncoming, status_read );

					t_Tuple *pTupleNext = (t_Tuple *)pTuple2ReadIncoming->pNext;
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming->ptBuf->pData );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming->ptBuf );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming );
					pTuple2ReadIncoming = pTupleNext;
				}
				pReader->p_TplList2Read = CL_NULL;

				// BRY_01102015
//				if ( response_received )
//				{
//					DEBUG_PRINTF("clReaderReadThread_%s: SEND_ACK", pReader->tCOMParams.aucPortName );
//
//					SendDataToReader( pReader, bufferACK, 2 );
//
//					//
//					// Free the Ack sended
//					//
//					t_Tuple *pTuple2Send = pReader->p_TplList2Send;
//					while ( pTuple2Send != NULL )
//					{
//						pReader->tCallBacks.fnIOSendDataDone_cb( pReader, pTuple2Send, status_read );
//
//						t_Tuple *pTupleNext = (t_Tuple *)pTuple2Send->pNext;
//						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf->pData );
//						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf );
//						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send );
//						pTuple2Send = pTupleNext;
//					}
//					pReader->p_TplList2Send = CL_NULL;
//
//					DEBUG_PRINTF("clReaderReadThread_%s: WRITE_COMPLETE", pReader->tCOMParams.aucPortName );
//					pCtxt->ptHalFuncs->fnSemaphoreRelease( pReader->tSync.pSgl4ReadComplete );
//				}
			}
		}

		if ( status_read == CL_TIMEOUT_ERR )
		{
			DEBUG_PRINTF1("clReaderReadThread_%s: TIMEOUT", pReader->tCOMParams.aucPortName);
		}

		if ( status_read == CL_MEM_ERR )
		{
			DEBUG_PRINTF("clReaderReadThread_%s: MEMORY_ERROR", pReader->tCOMParams.aucPortName);
		}

		if ( status_read == CL_ERROR_IN_COMM )
		{
			DEBUG_PRINTF("clReaderReadThread_%s: ERROR_IN_COMM", pReader->tCOMParams.aucPortName);

			// BRY_02102015 - Attendre la stabilisation du SerialPort ...?
			// pCtxt->ptHalFuncs->fnWaitMs( 1000 );  // > 500 non ca ne donne rien
			// ReportStatusEvent: !fWaitingOnStat pette toujours lors de la prochaine lecture

			//
			// BreakDownCommPort
			//
			if ( cl_ReaderRemoveFromList( pReader ) != CL_OK )
			{
				DEBUG_PRINTF("clReaderReadThread: ReaderRemoveFromList: ERROR");
			}
			else
			{
				DEBUG_PRINTF("clReaderReadThread: ReaderRemoveFromList: OK");
			}

			DEBUG_PRINTF("clReaderReadThread: ExitProcess(0)");
			ExitProcess(0);
		}
	}
	while ( 1 );
}

/*--------------------------------------------------------------------------*\
 * Write Thread in mode Session
\*--------------------------------------------------------------------------*/
e_Result SESSION_MODE_CANCELED_clReaderWriteThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt 		= CL_NULL;
	e_Result 		status 		= CL_ERROR;
	t_Reader 		*pReader 	= CL_NULL;
	clu8			cancel		= 1; // bidon
	t_Tuple			*pLocalTupleList	= CL_NULL;
	t_Tuple			*pTuple2Send = CL_NULL;
	t_Tuple			*pTuple2Read = CL_NULL;
	e_SERIAL_RetryProtocolDef eSynchroStatus = CL_SERIAL_PROT_DEFAULT;

	clu8 			bufferACK[2] = "06";

	if ( CL_FAILED( status = cl_GetContext( &pCtxt ) ) )
		return CL_ERROR;

	pReader = pCallingReader;

	DEBUG_PRINTF("clReaderWriteThread: DoBEGIN");

	do
	{
		pCtxt->ptHalFuncs->fnDestroyThreadAsked( &cancel );

		status = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4Write, 5000 );
		if ( status == CL_TIMEOUT_ERR )
		{
			DEBUG_PRINTF("clReaderWriteThread: %s Waiting ...", pReader->aucLabel);
			continue;
		}

		cl_ReaderGetSyncStatus("W", pReader, &eSynchroStatus );
		switch ( eSynchroStatus )
		{
			case CL_SERIAL_PROT_DEFAULT : // new data to send => initialize state machine

				if ( g_TimeOut == false )
				{
					MUTEX_INCOMING_READ_LOCK("clReaderWriteThread");

					DEBUG_PRINTF("clReaderWriteThread: IO_SEND_DATA");

					cl_ReaderSetSyncStatus( "W", pReader, CL_SERIAL_PROT_W_WAIT_FOR_ACK );

					pLocalTupleList	= pReader->p_TplList2Send;
					status = pReader->tReaderHalFuncs.fnIOSendData( pReader, pLocalTupleList->ptBuf );

					pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read);
				}
				else
				{
					DEBUG_PRINTF("clReaderWriteThread: WRITE_TIMEOUT");

					g_TimeOut = false; // Reset Timeout given by ReadThread

					//
					// Because free could not have beeing done at the end of
					// write cycle
					//
					pTuple2Send = pReader->p_TplList2Send;
					while ( pTuple2Send != NULL )
					{
						t_Tuple *pTupleNext = (t_Tuple *)pTuple2Send->pNext;
						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf->pData );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send );
						pTuple2Send = pTupleNext;
					}

					MUTEX_INCOMING_READ_UNLOCK("clReaderWriteThread");
				}

				break;

			case CL_SERIAL_PROT_R_RECEIVED_ACK : // 0x06 was received from read thread

				cl_ReaderSetSyncStatus( "W", pReader, CL_SERIAL_PROT_W_WAIT_FOR_ANSW );
				pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read);

				break;

			case CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED :

					SendDataToReader(pReader, bufferACK, 2);

					cl_ReaderSetSyncStatus( "W", pReader, CL_SERIAL_PROT_R_END_GRANTED );
					pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read);

				break;

			case CL_SERIAL_PROT_W_END_DONE : // Machine state cycle is finished, do the cleaning

				if ( pReader->p_TplList2Send == CL_NULL )
				{
					DEBUG_PRINTF("clReaderWriteThread: p_TplList2Send == NULL");
				}
				else
				{
					//
					// Give Tuples to upper layer, free all memory allocated by Write Cycle
					//
					pTuple2Send = pReader->p_TplList2Send;
					while ( pTuple2Send != NULL )
					{
						pReader->tCallBacks.fnIOSendDataDone_cb( pReader, pTuple2Send, status );

						t_Tuple *pTupleNext = (t_Tuple *)pTuple2Send->pNext;
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send->ptBuf->pData );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send->ptBuf );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Send );
						pTuple2Send = pTupleNext;
					}
					pReader->p_TplList2Send = CL_NULL;

					pTuple2Read = pReader->p_TplList2Read;
					while ( pTuple2Read != NULL )
					{
						pReader->tCallBacks.fnIOData2Read_cb( pReader, pTuple2Read, status );

						t_Tuple *pTupleNext = (t_Tuple *)pTuple2Read->pNext;
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Read->ptBuf->pData );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Read->ptBuf );
						pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2Read );
						pTuple2Read = pTupleNext;
					}
					pReader->p_TplList2Read = CL_NULL;
				}

				//
				// Reset ReadThread
				//
				cl_ReaderSetSyncStatus("W", pReader, CL_SERIAL_PROT_DEFAULT );
				pCtxt->ptHalFuncs->fnSemaphoreRelease( pReader->tSync.pSgl4Read );

				//
				// Tell upper layer than a new write can begin
				//
				DEBUG_PRINTF("clReaderWriteThread: fnSemaphoreRelease( pReader_tSync_pSgl4WriteComplete )");
				pCtxt->ptHalFuncs->fnSemaphoreRelease( pReader->tSync.pSgl4WriteComplete );

				MUTEX_INCOMING_READ_UNLOCK("clReaderWriteThread");

				break;

			default :

				cl_ReaderSetSyncStatus("W", pReader, CL_SERIAL_PROT_DEFAULT );
				MUTEX_INCOMING_READ_UNLOCK("clReaderWriteThread");

				break;
		}
	}
	while ( 1 );
}

/*--------------------------------------------------------------------------*\
 * Problem : the case "ack is not received" is not manage
\*--------------------------------------------------------------------------*/

e_Result SESSION_MODE_CANCELED_clReaderReadThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt 				= CL_NULL;
	e_Result 		 status_cl 			= CL_ERROR;
	e_Result 		 status_read 		= CL_ERROR;
	e_Result 		 status_incoming 	= CL_ERROR;
	t_Reader 		*pReader = CL_NULL;
	e_State			 eState;
	clu8			 cancel	=	1;
	e_SERIAL_RetryProtocolDef eSynchroStatus	=	CL_SERIAL_PROT_DEFAULT;
	t_Tuple			*pTuple2Read = CL_NULL;
    clu32 			nbTupleReceived  = 0;
	t_Tuple			*pTuple2ReadIncoming = CL_NULL;
    clu32 			nbTupleIncoming  = 0;

    clu8 			bufferACK[2] = "06";

	if ( CL_FAILED( status_cl = cl_GetContext( &pCtxt ) ) )
		return CL_ERROR;

	pReader = pCallingReader;

	DEBUG_PRINTF("clReaderReadThread: DoBEGIN");

	do
	{
		pCtxt->ptHalFuncs->fnDestroyThreadAsked( &cancel );

		if ( pReader == CL_NULL )
		{
			DEBUG_PRINTF("clReaderReadThread: Destroyed_Reader_IS_NULL");
			continue; // return waiting for cancellation
		}

		//
		// Wait for a connected reader
		// TODO!!!! do not enter read/write status if not connected. Put semaphore in place!!!
		//
		cl_ReaderGetState( pReader, &eState );
		if ( eState != STATE_CONNECT )
		{
			DEBUG_PRINTF("clReaderReadThread_%s Reader: NOT CONNECTED", pReader->tCOMParams.aucPortName);
			pCtxt->ptHalFuncs->fnWaitMs( 1000 );

			continue; // return waiting for cancellation
		}

		//
		// Wait for signal to read otherwise read incoming
		//
		status_incoming = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4Read, 300 ); // 350 // 500 // 1000 / 5000 if nothing to be read
		if ( status_incoming == CL_TIMEOUT_ERR )
		{

#ifdef READ_INCOMING

			//
			// Do not ReadIncoming, if state is not CL_SERIAL_PROT_DEFAULT
			//
			cl_ReaderGetSyncStatus("ReadIncoming", pReader, &eSynchroStatus );
			if ( eSynchroStatus != CL_SERIAL_PROT_DEFAULT )
			{
				continue;
			}

			MUTEX_INCOMING_READ_LOCK("ReadIncoming");

			nbTupleIncoming = 0;

			//
			// There is no Write Request, so lets try to read something incoming
			//
			DEBUG_PRINTF_READ_INCOMING("clReaderReadThread_%s Read_Incoming", pReader->tCOMParams.aucPortName);

			status_incoming = pReader->tReaderHalFuncs.fnIOGetData( pReader,  &pReader->p_TplList2Read );
			if ( status_incoming == CL_OK )
			{
				DEBUG_PRINTF("clReaderReadThread_%s: INCOMING_OK: %X", pReader->tCOMParams.aucPortName, pReader->p_TplList2Read);

				pTuple2ReadIncoming = pReader->p_TplList2Read;
				while ( pTuple2ReadIncoming != NULL )
				{
					// Count how many tuples are received
					nbTupleIncoming += 1;
					pTuple2ReadIncoming = pTuple2ReadIncoming->pNext;
				}

				// Send an ack to a received frame
				if ( nbTupleIncoming >= 1 )
				{
					DEBUG_PRINTF("clReaderReadThread_%s: INCOMING_SEND_ACK", pReader->tCOMParams.aucPortName);
					SendDataToReader( pReader, bufferACK, 2 );
				}

				DEBUG_PRINTF_READ_INCOMING("clReaderReadThread_%s: IOGetData: Incoming [%d]", pReader->tCOMParams.aucPortName, nbTupleIncoming);

				//
				// Give Tuples to upper layer
				//
				pTuple2ReadIncoming = pReader->p_TplList2Read;
				while ( pTuple2ReadIncoming != NULL )
				{
					pReader->tCallBacks.fnIOData2Read_cb( pReader, pTuple2ReadIncoming, status_incoming );

					t_Tuple *pTupleNext = (t_Tuple *)pTuple2ReadIncoming->pNext;
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming->ptBuf->pData );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming->ptBuf );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pTuple2ReadIncoming );
					pTuple2ReadIncoming = pTupleNext;
				}
				pReader->p_TplList2Read = CL_NULL;

				//
				// Free the Ack
				//
				t_Tuple *pTuple2Send = pReader->p_TplList2Send;
				while ( pTuple2Send != NULL )
				{
					pReader->tCallBacks.fnIOSendDataDone_cb( pReader, pTuple2Send, status_incoming );

					t_Tuple *pTupleNext = (t_Tuple *)pTuple2Send->pNext;
					pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf->pData );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send->ptBuf );
					pCtxt->ptHalFuncs->fnFreeMemSafely( (void **)&pTuple2Send );
					pTuple2Send = pTupleNext;
				}
				pReader->p_TplList2Send = CL_NULL;
			}

			if ( status_incoming == CL_TIMEOUT_ERR )
			{
				DEBUG_PRINTF("clReaderReadThread_%s: INCOMING_TIMEOUT", pReader->tCOMParams.aucPortName);

//				pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pReader->p_TplList2Read->ptBuf->pData );
//				pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pReader->p_TplList2Read->ptBuf );
//				pCtxt->ptHalFuncs->fnFreeMemSafely( (clvoid **)&pReader->p_TplList2Read );
			}

			if ( status_incoming == CL_MEM_ERR )
			{
				DEBUG_PRINTF("clReaderReadThread_%s: INCOMING_MEMORY_ERROR", pReader->tCOMParams.aucPortName);
			}

			if ( status_incoming == CL_ERROR_IN_COMM )
			{
				DEBUG_PRINTF("clReaderReadThread_%s: INCOMING_ERROR_IN_COMM", pReader->tCOMParams.aucPortName);
			}

			MUTEX_INCOMING_READ_UNLOCK("ReadIncoming");

#endif

			continue; // return to waiting for pSgl4Read
		}

		cl_ReaderGetSyncStatus( "R", pReader, &eSynchroStatus );
		switch ( eSynchroStatus )
		{
			case CL_SERIAL_PROT_DEFAULT : // Initiale state machine

				nbTupleReceived = 0;

				DEBUG_PRINTF("clReaderReadThread: %s Waiting_For_New_Read ...", pReader->aucLabel);

				break;

			case CL_SERIAL_PROT_W_WAIT_FOR_ACK : // WriteThread is waiting for ReadThread to receive 0x06

				status_read = pReader->tReaderHalFuncs.fnIOGetData( pReader, &pReader->p_TplList2Read );
				if ( status_read == CL_OK )
				{
					DEBUG_PRINTF("clReaderReadThread_%s: IO_GET_DATA_OK", pReader->tCOMParams.aucPortName);

					pTuple2Read = pReader->p_TplList2Read;
					while ( pTuple2Read != NULL )
					{
						// Count how many tuples are received
						nbTupleReceived += 1;
						pTuple2Read = pTuple2Read->pNext;
					}

					g_TimeOut = false;

					cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_R_RECEIVED_ACK );
				}

				if ( status_read == CL_TIMEOUT_ERR )
				{
					DEBUG_PRINTF("clReaderReadThread_%s: IO_GET_DATA_TIMEOUT", pReader->tCOMParams.aucPortName);

					g_TimeOut = true;

					cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_DEFAULT );
				}

				pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Write);

				break;

			case CL_SERIAL_PROT_W_WAIT_FOR_ANSW :

				DEBUG_PRINTF("clReaderReadThread_%s: nbTupleReceived: %d", pReader->tCOMParams.aucPortName, nbTupleReceived );

				if ( nbTupleReceived == 0 )
				{
					DEBUG_PRINTF("clReaderReadThread_%s: NOT_RECEIVING: ERROR", pReader->tCOMParams.aucPortName);
					status_read = pCtxt->ptHalFuncs->fnSemaphoreWait( pReader->tSync.pSgl4ReadComplete, 3000 );
					if ( status_read == CL_TIMEOUT_ERR )
					{
						DEBUG_PRINTF("clReaderReadThread: NOT_RECEIVING: TIMEOUT");

						cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_W_END_DONE );
						pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Write);
					}
				}

				if ( nbTupleReceived == 1 ) // We received ack now try to receive the answer
				{
					status_read = pReader->tReaderHalFuncs.fnIOGetData( pReader, &pReader->p_TplList2Read );
					if ( status_read == CL_OK )
					{
						DEBUG_PRINTF("clReaderReadThread_%s: IOGetData_OK", pReader->tCOMParams.aucPortName);

						pTuple2Read = pReader->p_TplList2Read;
						while ( pTuple2Read != NULL )
						{
							// Count how many tuples are received
							nbTupleReceived += 1;
							pTuple2Read = pTuple2Read->pNext;
						}

						g_TimeOut = false;

						cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_W_WAIT_FOR_ANSW );
						pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read); // auto_wake_up
					}

					if ( status_read == CL_TIMEOUT_ERR )
					{
						DEBUG_PRINTF("clReaderReadThread_%s: NOT_COMPLETE: ERROR", pReader->tCOMParams.aucPortName);

						cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_R_END_GRANTED );
						pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Read); // auto_wake_up
					}
				}

				if ( nbTupleReceived > 1 ) // We received ack and answers
				{
					//
					// Ask WriteThread to Write ACK
					//
					cl_ReaderSetSyncStatus("R", pReader, CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED );
					pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Write);
				}

				break;

			case CL_SERIAL_PROT_R_END_GRANTED : // Machine state cycle is finished, ask WriteThread to do the cleaning

				cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_W_END_DONE );
				pCtxt->ptHalFuncs->fnSemaphoreRelease(pReader->tSync.pSgl4Write);

				break;

			default : // What to do ? Return in state default !

				DEBUG_PRINTF("clReaderReadThread_%s: ERROR: cl_ReaderSetSyncStatus: CL_SERIAL_PROT_DEFAULT", pReader->tCOMParams.aucPortName);
				cl_ReaderSetSyncStatus( "R", pReader, CL_SERIAL_PROT_DEFAULT );

				break;
		}

	}
	while ( 1 );
}

/**************************************************************************/
/* Name : e_Result clReaderWriteThread( clvoid *pCallingReader );             			*/
/* Description :                                                        */
/*        Thread which handles write operation from application to low-layers	*/
/*		  on failure, the thread auto-destroy itself					*/
/**************************************************************************/
/* Parameters:                                                            */
/*  --------------                                                        */
/*  In: 	void *pCallingReader : pointer on reader struct this thread is 	*/
/*				associated to											  */
/* ---------------                                                        */
/*  Out: none                                                             */
/* Return value: e_Result                                                 */
/*  CL_OK                        :  Result is OK                          */
/**************************************************************************/
e_Result VERYOLD_STINKS_SHIT_clReaderWriteThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt = CL_NULL;
	e_Result 		status = CL_ERROR;
	t_Reader 		*pCrtReader = CL_NULL;
	t_Tuple 		*pTuple = CL_NULL;
	e_State			eState;
	clu8			bidon	=	0; // BRY_1404 c'est une grosse faute car non utilisé !!!!!
	e_SERIAL_RetryProtocolDef eSyncStatus	=	CL_SERIAL_PROT_DEFAULT;
	t_Buffer 		tLocalBuf;
	t_Tuple			*pLocalTuple = CL_NULL;
	clu8			*pData2Send	= CL_NULL;
	t_Tuple			*pLocalTupleList	= CL_NULL;
	clu8			u8LoopBack	=	0;
	// check params
	if ( pCallingReader == CL_NULL)
		return ( CL_OK );

	// store calling reader which initiates the creation of the thread for read
	pCrtReader = pCallingReader;

	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

	DEBUG_PRINTF("clReaderWriteThread: BEGIN");

	// check global parameters
	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnSemaphoreWait == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnSemaphoreRelease == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnFreeMem == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnGetTime == CL_NULL )
		return ( CL_ERROR );

	if ( pCrtReader->tCallBacks.fnIOSendDataDone_cb == CL_NULL )
		return ( CL_ERROR );

	if ( pCrtReader->tReaderHalFuncs.fnIOSendData == CL_NULL )
		return ( CL_ERROR );

	if ( pCrtReader->tReaderHalFuncs.fnIOCloseConnection == CL_NULL )
		return ( CL_ERROR );

	DEBUG_PRINTF("clReaderWriteThread: do {}");

	// at this stage of the thread, the connection with the reader was already opened.
	// on any error, we shall:
	//	- close the connection with the reader
	//  - remove it from the list of registered readers
	//  - signal it to upper layers

	do
	{
		if ( CL_FAILED(  pCtxt->ptHalFuncs->fnDestroyThreadAsked( &bidon ) ) )
			break;

		if ( /*u8DestroyThread*/ bidon != 0 )	//if a destroy was asked .. then proceed :)
		{
			status = CL_ERROR;
			break;
		}

		// wait for a connected reader
		if ( CL_FAILED(  status = cl_ReaderGetState( pCrtReader, &eState ) ) )
			break;

		// check it is connected
		// TODO!!!! do not enter read/write status if not connected. Put semaphore in place!!!
		if (( eState != STATE_CONNECT ) & ( eState != STATE_DISCOVER ) & ( eState != STATE_OTA ))
		{
			pCtxt->ptHalFuncs->fnWaitMs( 500 );
			continue;
		}

		// wait indefinitely for signal to this reader
		//DEBUG_PRINTF("---- Wait pSgl4Write 1 \n");
        status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4Write,  50000 );

		if (( status != CL_OK ) & (status != CL_TIMEOUT_ERR ))
			break;

		// catch new Tuple List
		if ( pCrtReader->p_TplList2Send != CL_NULL )
		{
			pLocalTupleList	= pCrtReader->p_TplList2Send;
			pCrtReader->p_TplList2Send	=	CL_NULL;
		}

		pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Write ); //DEBILE !!!! BRY_SYS

		do
		{
			if ( CL_FAILED(  pCtxt->ptHalFuncs->fnDestroyThreadAsked( &bidon ) ) )
				break;

			if ( bidon != 0 )	//if a destroy was asked .. then proceed :)
			{
				status = CL_ERROR;
				break;
			}

			// wait for a connected reader
			if ( CL_FAILED(  status = cl_ReaderGetState( pCrtReader, &eState ) ) )
				break;


			// check it is connected
			// TODO!!!! do not enter read/write status if not connected. Put semaphore in place!!!
			if (( eState != STATE_CONNECT ) & ( eState != STATE_DISCOVER ) & ( eState != STATE_OTA ))
			{
				pCtxt->ptHalFuncs->fnWaitMs( 500 );
				//pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Write ); // BRY_SYS
				continue;
			}

			// wait for data from user land before accessing the low level and writing to the device

			// load first element of tuple list and exit if none
			if ( pLocalTupleList == CL_NULL )
				break;

			u8LoopBack	=	0;
			// retry / tiemout machine handling
			cl_ReaderGetSyncStatus("W",  pCrtReader, &eSyncStatus );
			// retry_timeout machine
			switch ( eSyncStatus )
			{
				case  	( CL_SERIAL_PROT_W_WAIT_FOR_ANSW ):		// check if we received a ANSW from lower layer
				{
//					DEBUG_PRINTF("--- WRITE WAIT ACK 1 ------ (CL_SERIAL_PROT_W_WAIT_FOR_ANSW) %d\n", cl_GetElapsedTime());
					while ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  0xFFFFFFFF ) ) );
//					DEBUG_PRINTF(" WRITE GOT ACK!! -------->  (CL_SERIAL_PROT_W_WAIT_FOR_ANSW) %d\n", cl_GetElapsedTime());
					u8LoopBack		=	1;
					break;
				}
				case ( CL_SERIAL_PROT_R_RECEIVED_ACK ):	// 0x06 was received from read thread. Depending on type of Command sent, either Wait for the answer or exit
				{
//					DEBUG_PRINTF(" WRITE WAIT ACK 1 -------->  (Waiting for data: CL_SERIAL_PROT_R_RECEIVED_ACK) %d\n", cl_GetElapsedTime());

					while ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  0xFFFFFFFF ) ) );
//					DEBUG_PRINTF(" WRITE GOT ACK!! -------->  (CL_SERIAL_PROT_R_RECEIVED_ACK) %d\n", cl_GetElapsedTime());
					u8LoopBack = 1;
					break;
				}

				case ( CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED ):
				{
					// unstack previous command
					// release memory for tuple
					pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf->pData );
					pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf );

					// take next element of the list
					pTuple = ( t_Tuple *)pLocalTupleList->pNext;
					//pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList );
					pLocalTupleList	=	pTuple;
//					pCrtReader->p_TplList2Send = pTuple;

					// emit a 0x06 => insertion of a tuple in the queue for this...
					// first allocate tuple
#ifdef TATA
					// allocate memory for this buffer
					//status = pCtxt->ptHalFuncs->fnAllocMem( ( clvoid **)&pLocalTuple, sizeof( t_Tuple *) );
					status = csl_malloc( ( clvoid **)&pLocalTuple, sizeof( t_Tuple *) );
					if ( CL_FAILED( status ))
					{
						DEBUG_PRINTF("clReaderWriteThread: csl_malloc(pLocalTuple): FAILED");
						break;
					}


					// allocate memory for this buffere
					//status = pCtxt->ptHalFuncs->fnAllocMem( ( clvoid **)&pData2Send, 1 );
					status = csl_malloc( ( clvoid **)&pData2Send, 1 );
					if ( CL_FAILED( status ))
					{
						DEBUG_PRINTF("clReaderWriteThread: csl_malloc(pData2Send): FAILED");
						pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple );
						break;
					}

					// set ACK
					//*pData2Send	= 0x06;
					pData2Send[0] = CLOVER_SERIAL_ACK;

					if ( CL_SUCCESS( cl_initTuple( pLocalTuple, CL_NULL, &pData2Send, 1 ) ) )
					{
						DEBUG_PRINTF("WriteThread: ACK_SEND: 0x%02X", pData2Send[0]);
//						cl_sendData( (t_Device*)CL_NULL, pCrtReader, pLocalTuple, NON_BLOCKING, &bidon );
						//pCtxt->ptHalFuncs->fnWaitMs( 50 ); BRY_WRONG_WAY
					}
					else
					{
						DEBUG_PRINTF("WriteThread: ERROR : cl_initTuple FAILED !");
					}

					// specify that this tuple is reserved for OTA needs
					pLocalTuple->tOptions.tCnct = TSP_LAYER_REQ_OTA_SVC;

					// insert ACK in List !!!! CAUTION shortcut as we can have many buffer. Current implementation of Tuple List just add one buffer at a time. To be upgraded to
					// allow insertion in the middle of the list
					pLocalTupleList	= pLocalTuple;

#endif

//					DEBUG_PRINTF("WriteThread: ANSW_to_COMMAND_Inserted in QUEUE!");

					// set retries to CSL framework value
					pCrtReader->tSync.u32Retries	= pCtxt->ptCslReader->tSync.u32Retries;

					// before sending to network, tag data with time stamp
					pCtxt->ptHalFuncs->fnGetTime( pLocalTupleList->cl8Time, sizeof( pLocalTupleList->cl8Time) );

					// reset the state machine e
					cl_ReaderSetSyncStatus( "W",pCrtReader, CL_SERIAL_PROT_W_END_REQUIRED ); // BRY_PRINT_DEBUG_STATUS

					// take the semaphore.....
					//DEBUG_PRINTF("--- WRITE WAIT ACK 1 ------ (CL_SERIAL_PROT_W_WAIT_FOR_ANSW) %d\n", cl_GetElapsedTime());
					//while ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  0xFFFFFFFF ) ) );
					//DEBUG_PRINTF(" WRITE GOT ACK!! -------->  Send 0x06  %d\n", cl_GetElapsedTime());
					break;
				}
				case ( CL_SERIAL_PROT_R_RECEIVED_NACK ):	// 0x15 was received from read thread. Reemit data to reader
				case ( CL_SERIAL_PROT_W_WAIT_FOR_ACK ):	// a write was issued by the write thread. Write is waiting for Read Thread to receive 0x06
				{
					if ( eSyncStatus == CL_SERIAL_PROT_R_RECEIVED_NACK )
					{
						DEBUG_PRINTF("WriteThread: !!!UNEXPECTED CL_SERIAL_PROT_R_RECEIVED_NACK!!!");
					}
					else
					{
						DEBUG_PRINTF("WriteThread: !!!UNEXPECTED CL_SERIAL_PROT_W_WAIT_FOR_ACK!!!");
					}
					// resend the last command if a timeout occured
                    cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_DEFAULT );
					pCrtReader->tSync.u32Retries--;
					DEBUG_PRINTF("WriteThread:DECREMENT RETRY COUNTER AND EXECUTE DEFAULT BUFFER SENDING\n");
				}
				case ( CL_SERIAL_PROT_DEFAULT ): // new data to send => initialize state machine
				{
					// before sending to network, tag data with time stamp
					pCtxt->ptHalFuncs->fnGetTime( pLocalTupleList->cl8Time, sizeof( pLocalTupleList->cl8Time) );

					// set retries to CSL framework value
					if ( pCrtReader->tSync.u32Retries == 0 )
					{
						pCrtReader->tSync.u32Retries	= pCtxt->ptCslReader->tSync.u32Retries;
						cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_W_END_REQUIRED );
					}
					else
					{
						// wait for ACK from the low level
						cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_W_WAIT_FOR_ACK );
					}

					// unblock any unasynchronous event from Read thread
					pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  50 ); // BRY_ j'ai touvé 1 ici, j'ai mis 50 ???

//					DEBUG_PRINTF(" WRITE WAIT ACK 1 -------->  (Send new data %d: CL_SERIAL_PROT_DEFAULT) %d\n", pLocalTupleList->ptBuf->ulLen, cl_GetElapsedTime());
//
//					// take the semaphore.....
//					pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  0xFFFFFFFF );
//					DEBUG_PRINTF(" WRITE GOT ACK 1!! -------->  (CL_SERIAL_PROT_DEFAULT) %d\n", cl_GetElapsedTime());
//

//					pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  1 );
//					DEBUG_PRINTF(" WRITE GOT ACK 2!! -------->  (CL_SERIAL_PROT_DEFAULT) %d\n", cl_GetElapsedTime());
				}

			}

			// go back to timer
			if ( u8LoopBack == 1 )
				continue;

			// send to lower level
			if ( ( eState == STATE_CONNECT ) | ( eState == STATE_OTA ) )
			{
				if ( pCrtReader->tReaderHalFuncs.fnIOSendData != CL_NULL )
				{
					DEBUG_PRINTF("WriteThread: fnIOSendData");
					status = pCrtReader->tReaderHalFuncs.fnIOSendData( pCrtReader, pLocalTupleList->ptBuf );
				}
				else
					pCtxt->ptHalFuncs->fnWaitMs( 500 );
			}
			else
			{
				if ( eState == STATE_DISCOVER )
				{
					if ( pCrtReader->tReaderDiscoverHalFuncs.fnIOSendData != CL_NULL )
					{
						status = pCrtReader->tReaderDiscoverHalFuncs.fnIOSendData( pCrtReader, pLocalTupleList->ptBuf );
					}
					else
						pCtxt->ptHalFuncs->fnWaitMs( 500 );
				}
				else
					continue;
			}

			// signal the completion of send on network if synchronization needs to be in an asynchronous way
			switch ( eState )
			{
				case ( STATE_CONNECT ):
				{
					// if a callback was specified
					if ( pCrtReader->tCallBacks.fnIOSendDataDone_cb != CL_NULL )
						// remove serial header-trailer if needed
					{
						// lock callback access before pushing to user land
						if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
						{
							pCrtReader->tCallBacks.fnIOSendDataDone_cb( pCrtReader, pLocalTupleList, status );
							pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
						}
						else
						{
							DEBUG_PRINTF("WriteThread:Failed to lock callback sync semaphore \n");
						}
					}
					break;
				}
				case ( STATE_OTA ):
				{
					// if a callback was specified, send to OTA service
					if ( pCrtReader->tCallBacks.fnOTASendDataDone_cb != CL_NULL )
					{
						// lock callback access before pushing to user land
						if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
						{
							pCrtReader->tCallBacks.fnOTASendDataDone_cb( pCrtReader, pLocalTupleList, status );
							pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
						}
						else
						{
							DEBUG_PRINTF("WriteThread:Failed to lock callback sync semaphore \n");
						}
					}
					// send for display if needed
					if ( pCrtReader->tCallBacks.fnIOSendDataDone_cb != CL_NULL )
					{
						// lock callback access before pushing to user land
						if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
						{
							pCrtReader->tCallBacks.fnIOSendDataDone_cb( pCrtReader, pLocalTupleList, status );
							pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
						}
						else
						{
							DEBUG_PRINTF("WriteThread:Failed to lock callback sync semaphore \n");
						}
					}
					break;
				}
				case ( STATE_DISCOVER ):
				{
					// if a callback was specified
					if ( pCrtReader->tCallBacksDiscover.fnIOSendDataDone_cb != CL_NULL )
					{
						// lock callback access before pushing to user land
						if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
						{
							// remove serial header-trailer if needed
							pCrtReader->tCallBacksDiscover.fnIOSendDataDone_cb( pCrtReader, pLocalTupleList, status );
							pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
						}
						else
						{
							DEBUG_PRINTF("WriteThread:Failed to lock callback sync semaphore \n");
						}

					}
					break;
				}
				default: break;
			}

			//********************************************************************************************************
			// at this stage, implements retry/wait serial protocol if necessary by synchronization with read thread
			//********************************************************************************************************

			// get synchrnous state
			cl_ReaderGetSyncStatus("W", pCrtReader, &eSyncStatus );

			if (( eSyncStatus != CL_SERIAL_PROT_R_END_GRANTED )	& ( eSyncStatus != CL_SERIAL_PROT_W_END_REQUIRED ))
			{
				// wait 300ms. It can only be released by the read thread

				char buffString[SIZE_MAX_BUFFER];
				strset(buffString, EOS);
				PrintBuffer(buffString, pLocalTupleList->ptBuf->pData, pLocalTupleList->ptBuf->ulLen, "%02X ");

				DEBUG_PRINTF("------> WriteThread: WAIT ACK 1 send %d oct : %s [etime:%d]", pLocalTupleList->ptBuf->ulLen, buffString, cl_GetElapsedTime() );
//				DEBUG_PRINTF("------> WriteThread: WAIT ACK 1 (Send new data %d lg: CL_SERIAL_PROT_DEFAULT)", pLocalTupleList->ptBuf->ulLen);

				DEBUG_PRINTF("WriteThread: Wait pSgl4ReadComplete: timeout: [%d]", pCrtReader->tSync.u32SerialTimeout*10 );
				if ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4ReadComplete,  pCrtReader->tSync.u32SerialTimeout*10 ) ) )
				{
					DEBUG_PRINTF("------> WriteThread: WRITE_FAILED_ACK/// WAIT ACK 1");

					// get synchrnous state
					cl_ReaderGetSyncStatus("W", pCrtReader, &eSyncStatus );

					// if it is not the last exchange then loop back
					if (( eSyncStatus != CL_SERIAL_PROT_R_END_GRANTED )	& ( eSyncStatus != CL_SERIAL_PROT_W_END_REQUIRED ))
					{
						DEBUG_PRINTF("WriteThread: Timeout Exceed: Retry !");
						cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_DEFAULT );
						// resend the last command if a timeout occured
						if ( pCrtReader->tSync.u32Retries-- )
							continue;
					}
				}
//				DEBUG_PRINTF(" WRITE GOT ACK GENERAL!! --------> %d\n", cl_GetElapsedTime());

			}

			// get synchrnous state
			cl_ReaderGetSyncStatus("W", pCrtReader, &eSyncStatus );

			// except for exit
            if (( eSyncStatus == CL_SERIAL_PROT_R_END_GRANTED )	 | ( eSyncStatus == CL_SERIAL_PROT_W_END_REQUIRED ))
			{
				DEBUG_PRINTF("WriteThread: :):):) CL_SERIAL_PROT_R_END_GRANTED :):):)");

				cl_ReaderSetSyncStatus("W", pCrtReader,CL_SERIAL_PROT_DEFAULT );
				pCrtReader->tSync.u32Retries	= pCtxt->ptCslReader->tSync.u32Retries;
			}
			else
				continue;



			//************************************************************************
			// NOW the retry mechanism is OVER..... release the buffer from user land
			//************************************************************************
			// unblock calling layer by signaling that the data was effectively sent
			//DEBUG_PRINTF("___ Release pSgl4Write 1 \n");
			//pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Write );

			if ( CL_FAILED( status )  )
			{
				DEBUG_PRINTF("WriteThread: release memory for all tuples: pLocalTupleList");
				// release memory for all tuples
				pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf->pData );
				pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf );
				pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList );
				// then exit
				break;
			}

#ifdef TUTU

			DEBUG_PRINTF("WriteThread: Release Memory used by Tuple: BEGIN");

			if (pLocalTupleList == CL_NULL)
			{
				DEBUG_PRINTF("WriteThread: pLocalTupleList is NULL");
			}
			else
			{
	 			// take next element of the list
	 			pTuple = ( t_Tuple *)pLocalTupleList->pNext;

	 			if (pTuple == CL_NULL)
	 			{
	 				DEBUG_PRINTF("WriteThread: pTuple is NULL");
	 			}

	             // release memory for tuple
	 			if (pLocalTupleList->ptBuf->pData == CL_NULL)
	 			{
	 				DEBUG_PRINTF("WriteThread: pLocalTupleList->ptBuf->pData is NULL");
	 			}
	 			else
	 			{
	 				e_Result er = pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf->pData );
	 				if (er == CL_PARAMS_ERR)
	 				{
	 					DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList->ptBuf->pData ) CL_PARAMS_ERR");
	 				}
	 				else
	 				{
	 					DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList->ptBuf->pData )");
	 				}
	 			}

	 			if (pLocalTupleList->ptBuf == CL_NULL)
	 			{
	 				DEBUG_PRINTF("WriteThread: pLocalTupleList->ptBuf is NULL");
	 			}
	 			else
	 			{
	 				e_Result er = pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList->ptBuf );
	 				if (er == CL_PARAMS_ERR)
					{
						DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList->ptBuf ) CL_PARAMS_ERR");
					}
					else
					{
						DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList->ptBuf )");
					}
	 			}

	 			if (pLocalTupleList == CL_NULL)
	 			{
	 				DEBUG_PRINTF("WriteThread: pLocalTupleList is NULL");
	 			}
	 			else
	 			{
	 				e_Result er = pCtxt->ptHalFuncs->fnFreeMem( pLocalTupleList );
	 				if (er == CL_PARAMS_ERR)
					{
						DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList ) CL_PARAMS_ERR");
					}
					else
					{
						DEBUG_PRINTF("WriteThread: fnFreeMem( pLocalTupleList )");
					}
	 			}

	 			if ( pTuple == CL_NULL)
	 			{
	 				DEBUG_PRINTF("WriteThread: ERROR : pTuple is NULL");
	 			}
	 			else
	 			{
	 				DEBUG_PRINTF("WriteThread: pLocalTupleList point to new Tuple");


	 				pLocalTupleList = pTuple;
	 			}

				DEBUG_PRINTF("WriteThread: Release Memory used by Tuple: END");
			}

			DEBUG_PRINTF("WriteThread: Release Memory WELLDONE");

#else

//			// BRY_1604 : free du tuple ???
//			DEBUG_PRINTF("WriteThread: fnFreeMem: pLocalTuple");
//			pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple->ptBuf->pData );
//			pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple->ptBuf );
//			pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple );
//			pCtxt->ptHalFuncs->fnFreeMem( pData2Send );

            pLocalTupleList = CL_NULL; // TODO : BRY : freeing memory correcly !!!
#endif

		}
		while ( 1 );

//		// BRY_2104 : free du tuple ??? ici ??? non plus !!!!!!
//		DEBUG_PRINTF("WriteThread: fnFreeMem: pLocalTuple");
//		pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple->ptBuf->pData );
//		pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple->ptBuf );
//		pCtxt->ptHalFuncs->fnFreeMem( pLocalTuple );

		//DEBUG_PRINTF("clReaderWriteThread: On passe ici ?"); oui oui on n'arrete pas de passer par là

		//
        //DEBUG_PRINTF("____ Release pSgl4Write 2 %x %d\n", pCrtReader->tSync.pSgl4Write, cl_GetElapsedTime() );
		//if ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Write ) ))
		//	break;
		// relieve thread if nothing is coming from upper layer
		pCtxt->ptHalFuncs->fnWaitMs( 500 );
	}
	while( 1 );

	DEBUG_PRINTF("clReaderWriteThread:END");

/*	if ( CL_FAILED( status ) )
	{
		DEBUG_PRINTF("Reader Write Thread closed due to pb\n");
		pCrtReader->tReaderHalFuncs.fnIOCloseConnection( pCrtReader );
		pCtxt->ptHalFuncs->fnSemaphoreDestroy( pCrtReader->tSync.pSgl4Read );
	}


	status = clRegisteredThread( clReaderReadThread );
	pCtxt->ptHalFuncs->fnDestroyThread( CL_NULL );
*/
	return ( CL_OK );
}


/********************************************************************************/
/* Name : e_Result clReaderReadThread( clvoid );             					*/
/* Description :                                                        		*/
/*        Thread which handles read operation from application to low-layers	*/
/*		  on failure, the thread auto-destroy itself							*/
/**************************************************************************/
/* Parameters:                                                            */
/*  --------------                                                        */
/*  In: 	none			    										*/
/* ---------------                                                        */
/*  Out: none                                                             */
/* Return value: e_Result                                                 */
/*  CL_OK                        :  Result is OK                          */
/**************************************************************************/
e_Result VERYOLD_STINKS_SHIT_clReaderReadThread( clvoid *pCallingReader )
{
	t_clContext 	*pCtxt 	= CL_NULL;
	e_Result 		status 	= CL_ERROR;
	t_Reader 		*pCrtReader = CL_NULL;
	t_Tuple 		*pTuple 	= CL_NULL;
	t_Tuple 		*pCrtTuple	= CL_NULL;
	e_State			eState		= STATE_INIT;
	clu8			u8DestroyThread	= 0;
	t_Tuple			*pLocalTupleList	=	CL_NULL;
	t_Tuple			*pLocalTuple = CL_NULL;
	clu8			*pData2Send	= CL_NULL;
    t_OtaInternal 	*pOta		=	CL_NULL;
    clu32			u32TsfNb		=	0;
	e_SERIAL_RetryProtocolDef eSyncStatus	=	CL_SERIAL_PROT_DEFAULT;
	clu32 			u32TupleIndex  = 0;

    // get pointer on OTA service
    if ( CL_FAILED( cl_getOTAService( &pOta ) ) )
    	return ( CL_ERROR );

    if ( pOta == CL_NULL )
    	return ( CL_ERROR );


	// check params
	if ( pCallingReader == CL_NULL)
		return ( CL_OK );

	// store calling reader which initiates the creation of the thread for read
	pCrtReader = pCallingReader;


	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

    DEBUG_PRINTF("clReaderReadThread: BEGIN");

    // check global parameters
	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnSemaphoreWait == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnSemaphoreRelease == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnFreeMem == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnAllocMem == CL_NULL )
		return ( CL_ERROR );

	if ( pCrtReader->tReaderHalFuncs.fnIOGetData == CL_NULL )
		return ( CL_ERROR );

	if ( pCrtReader->tReaderHalFuncs.fnIOCloseConnection == CL_NULL )
		return ( CL_ERROR );

    if ( pCtxt->ptHalFuncs->fnWaitMs == CL_NULL )
		return ( CL_ERROR );

    // BRY_2404 : this mean that call to cl_readerAddToList will exit here !!!???
    // ReadThread will never started
//    if (pCtxt->tClbCtrl.pSgl == CL_NULL )
//    	return ( CL_ERROR );


	// at this stage of the thread, the connection with the reader was already opened.
	// on any error, we shall:
	//	- close the connection with the reader
	//  - remove it from the list of registered readers
	//  - signal it to upper layers
    DEBUG_PRINTF("clReaderReadThread: do {}");

	do
	{
		if ( CL_FAILED(  pCtxt->ptHalFuncs->fnDestroyThreadAsked( &u8DestroyThread ) ) )
			break;

		if ( u8DestroyThread != 0 )	//if a destroy was asked .. then proceed :)
		{
			status = CL_ERROR;
			break;
		}

		// wait for a connected reader
		if ( CL_FAILED(  status = cl_ReaderGetState( pCrtReader, &eState ) ) )
			break;

		// BRY_02042015 attendre un peu ça mange pas de pain
//		pCtxt->ptHalFuncs->fnWaitMs( 1000 );

		// check it is connected
		// TODO!!!! do not enter read/write status if not connected. Put semaphore in place!!!
		if ( ( eState != STATE_CONNECT )  & ( eState != STATE_DISCOVER ) & ( eState != STATE_OTA )  )
		{
			pCtxt->ptHalFuncs->fnWaitMs( 1000 );	// BRY_2404
			continue;
		}

		if ( ( eState == STATE_CONNECT ) | ( eState == STATE_OTA ) | ( eState == STATE_DISCOVER ) )
		{
			status = ( pCrtReader->tReaderHalFuncs.fnIOGetData( (clvoid *)pCrtReader, &pTuple) );
			if ( status == CL_TIMEOUT_ERR )
			{
				pCtxt->ptHalFuncs->fnWaitMs( 3000 );
			}
		}
//		else
//		{
//			if ( eState == STATE_DISCOVER )
//			{
//				if ( pCrtReader->tReaderDiscoverHalFuncs.fnIOGetData != CL_NULL )
//				{
//					status = ( pCrtReader->tReaderDiscoverHalFuncs.fnIOGetData( (clvoid *)pCrtReader, &pTuple) );
//				}
//				else
//					pCtxt->ptHalFuncs->fnWaitMs( 500 );
//			}
//			else
//				continue;
//		}

		// wait for data from network
		if ( CL_SUCCESS( status ) )
		{
			u32TupleIndex	=	1;	// indicator for debug

			pCrtTuple = pTuple;		// get tuple list
			for ( ;; )
			{
				// if any data is coming from the network, send it to user land
				if ( pTuple != CL_NULL )
				{
					// before sending to upper layer, tag tuple with time stamp
					pCtxt->ptHalFuncs->fnGetTime( pCrtTuple->cl8Time, sizeof( pCrtTuple->cl8Time) );

					if ( pCrtTuple->ptBuf == CL_NULL )
					{
						DEBUG_PRINTF("ReadThread:Data from network : pCrtTuple->ptBuf == CL_NULL\n");
						break;
					}

					if ( pCrtTuple->ptBuf->pData == CL_NULL )
					{
						DEBUG_PRINTF("ReadThread:Data from network : pCrtTuple->ptBuf->pData == CL_NULL\n");
						break;
					}

					DEBUG_PRINTF("ReadThread:%s:<- Data From Network:Tuple.lg:%x Tuple.index:%d", pCrtTuple->cl8Time, pCrtTuple->ptBuf->ulLen, u32TupleIndex++ );

					/* points tuple to next element*/
					pTuple = ( t_Tuple *) pTuple->pNext ;

					/* pCrtTuple is sent to user land one by one, so we break the linked list */
					pCrtTuple->pNext = CL_NULL;

#ifdef TOTO
					// SYNCHRO!!
					// get current state
					cl_ReaderGetSyncStatus("W", pCrtReader, &eSyncStatus );
					switch ( eSyncStatus )
					{
						case ( CL_SERIAL_PROT_DEFAULT ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_DEFAULT\n");
							break;
						}
						case( CL_SERIAL_PROT_W_WAIT_FOR_ACK ):
						{
							if ( pCrtTuple->ptBuf->ulLen == 1)
							{
	                            DEBUG_PRINTF("ReadThread: ACK_RECEIVE: 0x%02x [etime:%d]", pCrtTuple->ptBuf->pData[0], cl_GetElapsedTime());

	                            if ( pCrtTuple->ptBuf->pData[0] == 0x06 )
									cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_R_RECEIVED_ACK );
								if ( pCrtTuple->ptBuf->pData[0] == 0x15 )
									cl_ReaderSetSyncStatus("W", pCrtReader, CL_SERIAL_PROT_R_RECEIVED_NACK );
							}
							break;
						}
						case ( CL_SERIAL_PROT_R_RECEIVED_ACK ): // BRY_0804
//						{
//							DEBUG_PRINTF("ReadThread->0x%x2", pCrtTuple->ptBuf->pData[0]);
//							// increment step of state machine to emit a 0x06 in the write thread
//							if ( pCrtTuple->ptBuf->ulLen != 0)
//								cl_ReaderSetSyncStatus( pCrtReader, CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED );
//							break;
//						}
						case ( CL_SERIAL_PROT_W_WAIT_FOR_ANSW ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_W_WAIT_FOR_ANSW %d\n", cl_GetElapsedTime());

                            // signal to the write thread that we received a data
//                            DEBUG_PRINTF("????? Release Read Complete 2 ??????\n");
  //                          pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4ReadComplete );

							// increment step of state machine to emit a 0x06 in the write thread
							if ( pCrtTuple->ptBuf->ulLen != 0)
								cl_ReaderSetSyncStatus("R", pCrtReader, CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED );

							// signal a progress in the OTA process with 5% progress
							if ( pCtxt->ptCallbacks->fnOTAProgress_cb )
							{
								pOta->u8OtaProgress += 5;

								// lock callback access before pushing to user land
								if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
								{
									pCtxt->ptCallbacks->fnOTAProgress_cb( CL_OTA_ENTER_DOWNLOAD_MODE, pCrtReader, pOta->u8OtaProgress );
									pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
								}
								else
								{
									DEBUG_PRINTF("ReadThread:Failed to lock callback sync semaphore 1\n");
								}

							}

							break;
						}
						case ( CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_R_WRITE_ACK_REQUIRED %d\n", cl_GetElapsedTime());
							cl_ReaderSetSyncStatus("R", pCrtReader, CL_SERIAL_PROT_DEFAULT );
							break;
						}
						case ( CL_SERIAL_PROT_W_END_REQUIRED ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_W_END_REQUIRED %d\n", cl_GetElapsedTime());
							cl_ReaderSetSyncStatus("R", pCrtReader, CL_SERIAL_PROT_R_END_GRANTED );
							break;
						}
						case ( CL_SERIAL_PROT_R_END_GRANTED ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_R_END_GRANTED %d\n", cl_GetElapsedTime());
							break;
						}
						case ( CL_SERIAL_PROT_W_END_DONE ):
						{
//							DEBUG_PRINTF("R: CL_SERIAL_PROT_W_END_DONE %d\n", cl_GetElapsedTime());
							break;
						}
						default:
						{
//							DEBUG_PRINTF("!!!!R: eSyncStatus unknown %x [%d]", eSyncStatus, cl_GetElapsedTime() );
							//cl_ReaderSetSyncStatus( pCrtReader, CL_SERIAL_PROT_DEFAULT );
							break;
						}
					}
#endif
					// signal to the write thread that we received a data
					if (( pTuple == CL_NULL ) | (( pTuple != CL_NULL ) & ( eSyncStatus != CL_SERIAL_PROT_W_WAIT_FOR_ACK)))
					{
						DEBUG_PRINTF("<------ ReadThread: READ ACK 1");
						pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4ReadComplete );
					}
					// SEND DATA TO USER LAND
					/* check if blocking call */
					if ( pCrtReader->tSync.eCallType == BLOCKING )
					{

						/* lock the semaphore to push to upper layers*/
						while( (  status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4Read, 1  ) ) == CL_TIMEOUT_ERR );

						// parse tuples list and add the new ones at the end of the list
						while ( pCrtReader->p_TplList2Read != CL_NULL )
							pCrtReader->p_TplList2Read = pCrtReader->p_TplList2Read->pNext;

						// add the new one
						pCrtReader->p_TplList2Read = pCrtTuple;
						pCrtReader->p_TplList2Read->pNext = CL_NULL;

						// signal we have a data ready for reading
						pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Read );


						/* lock the semaphore to push to upper layers*/
//						while( (  status = pCtxt->ptHalFuncs->fnSemaphoreWait( pCrtReader->tSync.pSgl4Read, 1  ) ) == CL_TIMEOUT_ERR );
					}
					else
					{
						// signal completion to upper layer if necessary
						switch ( eState )
						{
							case ( STATE_CONNECT ):
							{
								DEBUG_PRINTF("ReadThread:STATE_CONNECT");
								if ( pCrtReader->tCallBacks.fnIOData2Read_cb != CL_NULL )
								{
									// lock callback access before pushing to user land
									DEBUG_PRINTF("ReadThread:WAIT pCtxt->tClbCtrl.pSgl");
									if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
									{
										// remove serial header-trailer if needed
										pCrtReader->tCallBacks.fnIOData2Read_cb( (void *)pCrtReader,  (void *)pCrtTuple, status );
										pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
									}
									else
									{
										DEBUG_PRINTF("ReadThread: Failed to lock callback sync semaphore");
									}
								}
								break;
							}
							case ( STATE_OTA ):
							{
								DEBUG_PRINTF("ReadThread:STATE_OTA\n");
								// send to OTA service
								if ( pCrtReader->tCallBacks.fnOTAData2Read_cb != CL_NULL )
								{
									// lock callback access before pushing to user land
									if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
									{
										// remove serial header-trailer if needed
										pCrtReader->tCallBacks.fnOTAData2Read_cb( (void *)pCrtReader,  (void *)&pCrtTuple, status );
										pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
									}
									else
									{
										DEBUG_PRINTF("ReadThread:Failed to lock callback sync semaphore");
									}
								}
								// send a copy to upper layer for display
								if ( pCrtReader->tCallBacks.fnIOData2Read_cb != CL_NULL )
								{
									// lock callback access before pushing to user land
									if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
									{
										// remove serial header-trailer if needed
										pCrtReader->tCallBacks.fnIOData2Read_cb( (void *)pCrtReader,  (void *)pCrtTuple, status );
										pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
									}
									else
									{
										DEBUG_PRINTF("ReadThread: Failed to lock callback sync semaphore");
									}
								}

								break;
							}
							case ( STATE_DISCOVER ):
                            {
								DEBUG_PRINTF("ReadThread:STATE_DISCOVER\n");
                                if ( pCrtReader->tCallBacksDiscover.fnIOData2Read_cb )
                                {
									// lock callback access before pushing to user land
									if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnSemaphoreWait( pCtxt->tClbCtrl.pSgl, 100  ) ) )
									{
										// remove serial header-trailer if needed
										status = pCrtReader->tCallBacksDiscover.fnIOData2Read_cb( (void *)pCrtReader,  (void *)pCrtTuple, status );
										pCtxt->ptHalFuncs->fnSemaphoreRelease( pCtxt->tClbCtrl.pSgl );
									}
									else
									{
										DEBUG_PRINTF("ReadThread: Failed to lock callback sync semaphore");
									}
                                }
								break;
							}
							default:
								break;
						}

						// release the semaphore to signal that we can read now as we received some data
						pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Read );
					}


					/* free memory of data sent to user land */
					DEBUG_PRINTF("ReadThread: FreeMemory for pCrtTuple");
					pCtxt->ptHalFuncs->fnFreeMem( pCrtTuple->ptBuf->pData );
					pCtxt->ptHalFuncs->fnFreeMem( pCrtTuple->ptBuf );
					pCtxt->ptHalFuncs->fnFreeMem( pCrtTuple );
					pCrtTuple = pTuple;


					// reset current pointer for next message
					//pTuple = CL_NULL;

				}
				else
					break;
			}
			pTuple = CL_NULL;
		}
		else
		{
			// SYNCHRO!!
			// get current state

			DEBUG_PRINTF("ReadThread:Thread got an error !!! Exit\n");
            cl_ReaderGetSyncStatus("R", pCrtReader, &eSyncStatus );

            cl_ReaderSetSyncStatus("R", pCrtReader, CL_SERIAL_PROT_DEFAULT );
			pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4ReadComplete );


//			if ( eSyncStatus == CL_SERIAL_PROT_W_END_DONE)
//			{
//				cl_ReaderSetSyncStatus( pCrtReader, CL_SERIAL_PROT_DEFAULT );
//				// signal to the write thread that we received its completion signal
//                DEBUG_PRINTF("????? Release Read Complete 3 ?????? %d\n", cl_GetElapsedTime() );
//				DEBUG_PRINTF("<------ READ ACK 2 %d\n", cl_GetElapsedTime());
//
//				DEBUG_PRINTF("????? Release Read Complete 3 done ?????? %d\n", cl_GetElapsedTime() );
//
//			}

		}
		//
//			if ( CL_FAILED( status = pCtxt->ptHalFuncs->fnSemaphoreRelease( pCrtReader->tSync.pSgl4Read ) ))
//				break;

	}
	while( 1 );

	DEBUG_PRINTF("clReaderReadThread:END");

	if ( CL_FAILED( status ) )
	{
		DEBUG_PRINTF("ReadThread: Closed due to pb\n");
		pCrtReader->tReaderHalFuncs.fnIOCloseConnection( pCrtReader );
		pCtxt->ptHalFuncs->fnSemaphoreDestroy( pCrtReader->tSync.pSgl4Read );
	}

	clUnregisterThread( pCrtReader->tSync.tThreadId4Read, clReaderReadThread );
	pCtxt->ptHalFuncs->fnDestroyThread( CL_NULL );

	return ( CL_OK );

}
/********************************************************************************/
/* Name : e_Result clCryptoThread( clvoid );             					*/
/* Description :                                                        		*/
/*        Thread which handles access to crypto resource (one per CSL shared )	*/
/*		among readers 															*/
/*		  on failure, the thread auto-destroy itself							*/
/**************************************************************************/
/* Parameters:                                                            */
/*  --------------                                                        */
/*  In: 	none			    										*/
/* ---------------                                                        */
/*  Out: none                                                             */
/* Return value: e_Result                                                 */
/*  CL_OK                        :  Result is OK                          */
/**************************************************************************/
e_Result clCryptoThread( clvoid )
{

	t_clContext *pCtxt = CL_NULL;
	e_Result status = CL_ERROR;
//	pthread_mutex_t crypto_mutex = PTHREAD_MUTEX_INITIALIZER;
//	pthread_cond_t crypto_got_request = PTHREAD_COND_INITIALIZER;

	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	/* */
	for ( ;; )
	{

#if 0
		pCtxt->ptHalFuncs->fnSemaphoreWait( );

		/* first, lock crypto mutex */
		int rc = pthread_mutex_lock( &crypto_mutex );
		if (rc) { /* an error has occurred */
//		    perror("pthread_mutex_lock");
		    pthread_exit( CL_NULL );
		}
		// mutex is now locked - wait on condition variable (data to treat)  */
		/* During the execution of pthread_cond_wait, the mutex is unlocked. */
		rc = pthread_cond_wait( &crypto_got_request, &crypto_mutex);
		if (rc == 0) { /* we were awakened due to the cond. variable being signaled */
		               /* The mutex is now locked again by pthread_cond_wait()      */
		    /* do your stuff... */

		}
		// re-initialize condition for further use
		pthread_cond_init( &crypto_got_request, CL_NULL );
		// finally, unlock the mutex and loop again
		pthread_mutex_unlock( &crypto_mutex );
#endif

	}

	pCtxt->ptHalFuncs->fnDestroyThread( CL_NULL );

	return ( CL_OK );

}

/********************************************************************************/
/* Name : e_Result clRegisterThread( clvoid *fnThreadId, clu64 u64ThreadId ); 	*/
/* Description :                                                        		*/
/*        Register a thread in a thread list with its id to ease identification	*/
/*		and closure 															*/
/**************************************************************************/
/* Parameters:                                                            */
/*  --------------                                                        */
/*  In: 	none			    										*/
/* ---------------                                                        */
/*  Out: none                                                             */
/* Return value: e_Result                                                 */
/*  CL_OK                        :  Result is OK                          */
/**************************************************************************/
e_Result clRegisterThread( clvoid *fnThreadId, clu64 u64ThreadId )
{


	return ( CL_OK );
}

/********************************************************************************/
/* Name : e_Result clRegisteredThread(  clu64 u64ThreadId, clvoid *pu64ThreadId); */
/* Description :                                                        		*/
/*      Get the function pointer of the thread to allow its unregistration		*/
/*		  on failure, the thread auto-destroy itself							*/
/********************************************************************************/
/* Parameters:                                                            		*/
/*  --------------                                                        		*/
/*  In: 	none			    												*/
/* ---------------                                                        		*/
/*  Out: none                                                             		*/
/* Return value: e_Result                                                 		*/
/*  CL_OK                        :  Result is OK                          		*/
/********************************************************************************/
e_Result clRegisteredThread( clu64 u64ThreadId, clvoid *pu64ThreadId )
{

	return ( CL_OK );
}

/********************************************************************************/
/* Name : e_Result clCryptoThread( clvoid );             					*/
/* Description :                                                        		*/
/*        Thread which handles access to crypto resource (one per CSL shared )	*/
/*		among readers 															*/
/*		  on failure, the thread auto-destroy itself							*/
/**************************************************************************/
/* Parameters:                                                            */
/*  --------------                                                        */
/*  In: 	none			    										*/
/* ---------------                                                        */
/*  Out: none                                                             */
/* Return value: e_Result                                                 */
/*  CL_OK                        :  Result is OK                          */
/**************************************************************************/
e_Result clUnregisterThread(  clvoid *fnThreadId, clu64 u64ThreadId )
{

	return ( CL_OK );
}

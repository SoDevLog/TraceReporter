//**************************************************
/****************************************************/
/*               CLOVER SECURED LAYER				*/
/*				Ineo-Sense Copyright 2014			*/
/****************************************************/
/***************************************************/
/*  Name: comal_win32.c                				*/
/*													*/
/*  Created on: 3 déc. 2014							*/
/*      Author: fdespres							*/
/****************************************************/
/* Description : porting layer for com port access in */
/*	WIN32 environment								*/
/****************************************************/
#ifdef WIN32

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <string.h>

#include <windows.h>

#elif defined (linux)

#error not defined for this platform

#else

#error not defined for this platform

#endif

#include "..\..\csl.h"
#include "comal_win32.h"
#include "..\..\inc\generic.h"
#include "..\..\inc\cltuple.h"
#include "..\..\inc\clhelpers.h"
#include "..\..\inc\clreaders.h"

/*--------------------------------------------------------------------------*/

#define SIZE_MAX_BUFFER 512

/*--------------------------------------------------------------------------*/

static void _printBuffer(char *aString, char *aFormatString, ...)
{
    va_list theArgs;
    char 	theBuffer[SIZE_MAX_BUFFER];

    memset(theBuffer, 0, SIZE_MAX_BUFFER);
    va_start(theArgs, aFormatString);
    _vsnprintf(theBuffer, SIZE_MAX_BUFFER - 1, aFormatString, theArgs);
    strcat(aString, theBuffer);
}

/*--------------------------------------------------------------------------*\
 * Print aBuffer bytes by bytes in aString
 */
void PrintBuffer(char *aString, unsigned char *aBuffer, int aLenght, char *aFormatString)
{
	int i = 0;
	for ( i = 0; i < aLenght ; i++ )
	{
		_printBuffer( aString, aFormatString, aBuffer[i] );
	}
}

/******************************************************************************/
/* Name :  e_Result cl_COMAlResetWin32( clvoid *ptReader );                   */
/* Description : reset the com connection to a reader                     		*/
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : clvoid *pReader : pointer to a reader where to reset the connection*/
/*                           if NULL, reset complete network connection       */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                     */
/*  OK                        :  Result is OK                                 */
/*  ERROR,                    : Failure on execution                          */
/*  MEM_ERR,                  :  Failure on memory management (failure,       */
/*                                  allocation ....)                          */
/*  PARAMS_ERR,               :  Inconsistent parameters                      */
/*  TIMEOUT_ERR,              :  Overrun on timing                            */
/******************************************************************************/
e_Result cl_COMAlResetWin32(  clvoid *ptReader )
{
	return ( CL_OK );
}

/******************************************************************************/
/* Name :  e_Result cl_COMAlRegisterWin32( clvoid *ptReader );                */
/* Description : register a reader to the hosting os. It allows to implement  */
/*          a blocking call in the underneath layer on incoming packets from  */
/*          the com port and propagate a signal the library to the dedicated   */
/*          reader. Then the reader reads the data coming from the underneath */
/*          layer                                                             */
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : t_Reader *pReader : pointer to a reader that this library deals with */
/*                           if NULL, returns PARAMS_ERR                      */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                      */
/*  OK                        :  Result is OK                                  */
/*  ERROR,                    : Failure on execution                           */
/*  MEM_ERR,                  :  Failure on memory management (failure,        */
/*                                  allocation ....)                           */
/*  PARAMS_ERR,               :  Inconsistent parameters                       */
/*  TIMEOUT_ERR,              :  Overrun on timing                             */
/******************************************************************************/
e_Result cl_COMAlRegisterWin32(  clvoid *ptReader )
{
	return ( CL_OK );
}
/******************************************************************************/
/* Name :  e_Result cl_COMAlUnregisterWin32( clvoid *ptReader );                  */
/* Description : unregister a reader from the hosting os. It allows to remove */
/*          a blocking call in the underneath layer on incoming packets from */
/*          the network and not to propagate a signal the library to the     */
/*          reader.                                                          */
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : t_Reader *pReader : pointer to a reader that this library deals with */
/*                           if NULL, returns PARAMS_ERR                      */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                      */
/*  OK                        :  Result is OK                                  */
/*  ERROR,                    : Failure on execution                           */
/*  MEM_ERR,                  :  Failure on memory management (failure,        */
/*                                  allocation ....)                           */
/*  PARAMS_ERR,               :  Inconsistent parameters                       */
/*  TIMEOUT_ERR,              :  Overrun on timing                             */
/******************************************************************************/
e_Result cl_COMAlUnregisterWin32(  clvoid *ptReader )
{
	return ( CL_OK);
}

/******************************************************************************/
/* Name :  e_Result cl_COMAlSendDataWin32( clvoid *ptReader, t_Buffer *ptBuff);   */
/* Description : send data to a reader via the COM API. This access be    */
/*                shall be provided by the customer and vary depending on     */
/*              target host system OS                                         */
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : t_Reader *pReader : pointer to there reader where to send the data   */
/*                           if NULL, returns PARAMS_ERR                      */
/*        t_Buffer *ptBuff : pointer to data buffer                           */
/*                           if NULL, returns PARAMS_ERR                      */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                      */
/*                          * OK                                              */
/*                          * ERROR:   Failure on execution					  */
/*                          * MEM_ERROR : Memory Error (failure, allocation..)*/
/*                          * PARAMS_ERR : Inconsistent parameters            */
/*                          * TIMEOUT_ERR : Timeout when sending data over network */
/*                          * TRANSFER_IN_PROCESS_ERR: a transfer on this     */
/*                          reader is already ongoing                         */
/******************************************************************************/
e_Result cl_COMAlSendDataWin32( clvoid *ptReader, t_Buffer *ptBuff)
{
	t_clContext *pCtxt 		= CL_NULL;
	e_Result status 		= CL_NULL;
	clu32 	iReturnCode 	= 0;
    t_Tuple *ptTuple		= CL_NULL;
    t_Buffer *pLocalBuf		= CL_NULL;
    clu8	*pData			= CL_NULL;
    t_Reader *pReader		= (t_Reader *)ptReader;
	cl8		*pMsg			= CL_NULL;
	OVERLAPPED osWrite = {0};
	DWORD dwWritten;
	DWORD dwRes;
	BOOL fRes;

	DEBUG_PRINTF("cl_COMAlSendDataWin32:BEGIN");

	// check incoming parameters
	if ( pReader == CL_NULL )
		return ( CL_PARAMS_ERR );

	if ( ptBuff == CL_NULL )
		return ( CL_PARAMS_ERR );


	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnAllocMem == CL_NULL)
		return ( CL_ERROR );

	for (;;)
	{
		DEBUG_PRINTF("cl_COMAlSendDataWin32:Thread:BEGIN");

		//----
		// perform a local copy of incoming buff to apply format change with serial support without corrupting incoming data (which is used subsequently in CSL)
		//----
		// allocate memory for structure t_Buffer
		if ( CL_FAILED( status = pCtxt->ptHalFuncs->fnAllocMem( ( clvoid **)&pLocalBuf, sizeof( t_Buffer ) ) ) )
			return ( CL_ERROR );

		if ( CL_FAILED( status = pCtxt->ptHalFuncs->fnAllocMem( ( clvoid **)&pData, ptBuff->ulLen ) ) )
		{
			pCtxt->ptHalFuncs->fnFreeMem( pLocalBuf );
			return ( CL_ERROR );
		}

		pLocalBuf->pData = pData;
		memcpy( pLocalBuf->pData, ptBuff->pData, ptBuff->ulLen);
		pLocalBuf->ulLen = ptBuff->ulLen;

		//DEBUG_PRINTF("\n 1. cl_COMAlSendDataWin32 %d \n", ptBuff->ulLen);

		//----
		// add the low level encapsulation if necessary
		//----
		if ( CL_FAILED( status = cl_HelperEncapsulateToSerial( pReader, pLocalBuf ) ) )
		{
			DEBUG_PRINTF("Failed on cl_HelperEncapsulateToSerial %s with Len %d\n ", pReader->tCOMParams.aucPortName, pLocalBuf->ulLen );
			break;
		}

		//DEBUG_PRINTF("\n 2. cl_COMAlSendDataWin32 %d \n", pLocalBuf->ulLen);

		// Do some basic settings
		DCB serialParams = { 0 };
		serialParams.DCBlength = sizeof(serialParams);

		if ( !GetCommState(pReader->u64Handle, &serialParams) )
		{
			DEBUG_PRINTF("cl_COMAlSendDataWin32:Error in GetCommState\n");
		}

		COMMTIMEOUTS readtimeout = { 0 };
		if ( !GetCommTimeouts( pReader->u64Handle, &readtimeout ) )
		{
			DEBUG_PRINTF("cl_COMAlSendDataWin32:Error in GetCommTimeouts\n");
		}

		// Create this write operation's OVERLAPPED structure's hEvent.
		osWrite.hEvent = CreateEvent(NULL, TRUE, FALSE, CL_NULL);
		if (osWrite.hEvent == CL_NULL)
		   // error creating overlapped event handle
		   break;

		//DEBUG_PRINTF("WRITE:  Reader handle is %x\n", pReader->u64Handle );
		// Issue write.
		if ( !WriteFile(pReader->u64Handle, (clvoid *) pLocalBuf->pData, pLocalBuf->ulLen, &dwWritten, &osWrite) )
		{
		   if (GetLastError() != ERROR_IO_PENDING)
		   {
			  // WriteFile failed, but isn't delayed. Report error and abort.
			  status = CL_ERROR;
		   }
		   else
		   {
			  // Write is pending.
			  dwRes = WaitForSingleObject(osWrite.hEvent, INFINITE);
			  switch(dwRes)
			  {
				 // OVERLAPPED structure's event has been signaled.
				 case WAIT_OBJECT_0:
				 {
					  if (!GetOverlappedResult(pReader->u64Handle, &osWrite, &dwWritten, FALSE))
							status = CL_ERROR;
					  else
					  {
						  // Write operation completed successfully.
						  status = CL_OK;
					  }
					  break;
				 }
				 default:
				 {
					  // An error has occurred in WaitForSingleObject.
					  // This usually indicates a problem with the
					 // OVERLAPPED structure's event handle.
					  status = CL_ERROR;
					  break;
				 }
			  }
		   }
		}
		else
		{
		   // WriteFile completed immediately.
		   status = CL_OK;
		}

		break;
	}

	char buffString[SIZE_MAX_BUFFER];
	strset(buffString, EOS);
	PrintBuffer(buffString, pLocalBuf->pData, pLocalBuf->ulLen, "%02X ");
    //DEBUG_PRINTF("------> cl_COMAlSendDataWin32: Send %d oct [%d] : %s", ptBuff->ulLen, cl_GetElapsedTime(), buffString ); // NULL cl_GetElapsedTime à la fin
	DEBUG_PRINTF("------> cl_COMAlSendDataWin32: Send %d oct : %s [time:%d]", ptBuff->ulLen, buffString, cl_GetElapsedTime() );

    if ( pLocalBuf )
    {
    	pData = pLocalBuf->pData;
    	pCtxt->ptHalFuncs->fnFreeMem( pLocalBuf );
    }
    if ( pData )
    	pCtxt->ptHalFuncs->fnFreeMem( pData );

    if ( osWrite.hEvent)
    {
    	// close handle to avoid leaks
    	CloseHandle ( osWrite.hEvent );
    }

	return ( status );
}
/******************************************************************************/
/* Name :  e_Result cl_COMAlGetStatus( clvoid *pReader);  */
/* Description : check that an event happened on the COM port (different from TX_EMPTY)	*/
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : clvoid *pReader : pointer to there reader where to send the data   */
/*                           if NULL, returns PARAMS_ERR                      */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                      */
/*                          * OK : read operation can proceed                   */
/*                          * ERROR:   do not enter read operation	*/
/******************************************************************************/
e_Result cl_COMAlGetStatus( clvoid *ptReader )
{
	t_Reader *pReader = ptReader;
	DWORD 		dwOvRes;
	DWORD      dwRes;
	DWORD      dwCommEvent;
	DWORD      dwStoredFlags;
	BOOL      fWaitingOnStat = FALSE;
	OVERLAPPED osStatus = {0};
	BOOL bWaitingOnStatusHandle;
	BOOL bExitFromThere = FALSE;
	e_Result	status = CL_ERROR;

#define STATUS_CHECK_TIMEOUT      500   // Milliseconds
/*   dwStoredFlags = EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING |\
                  EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY ;
   if (!SetCommMask(pReader->u64Handle , dwStoredFlags))
      // error setting communications mask; abort
      return ( CL_ERROR );
*/
   osStatus.hEvent = CreateEvent(NULL, TRUE, FALSE, CL_NULL);
   if (osStatus.hEvent == CL_NULL)
      // error creating event; abort
      return ( CL_ERROR );

   while ( bExitFromThere == FALSE)
   {
      // Issue a status event check if one hasn't been issued already.
      if (!fWaitingOnStat) {
         if (!WaitCommEvent( pReader->u64Handle , &dwCommEvent, &osStatus)) {
            if (GetLastError() == ERROR_IO_PENDING)
                fWaitingOnStat = TRUE;
//               bWaitingOnStatusHandle = TRUE;
            else
            {
            	fWaitingOnStat = FALSE;
               bExitFromThere = TRUE;
               // error in WaitCommEvent; abort
               break;
            }
         }
         else
         {
            // WaitCommEvent returned immediately.
            // Deal with status event as appropriate.
        	 DEBUG_PRINTF("Serial Event %x", dwCommEvent);
        	 if ( dwCommEvent & EV_BREAK )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_BREAK;\n");
        	 }
        	 if ( dwCommEvent & EV_CTS )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_CTS;\n");
        	 }
        	 if ( dwCommEvent & EV_DSR )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_DSR;\n");
        	 }
        	 if ( dwCommEvent & EV_ERR )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_ERR;\n");
        	 }
        	 if ( dwCommEvent & EV_RING )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_RING;\n");
        	 }
        	 if ( dwCommEvent & EV_RLSD )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_RLSD;\n");
        	 }
        	 if ( dwCommEvent & EV_RXCHAR )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_RXCHAR;\n");
        	 }
        	 if ( dwCommEvent & EV_RXFLAG )
        	 {
        		 DEBUG_PRINTF("Serial Event: EV_RXFLAG;\n");
        	 }
        	 bExitFromThere = TRUE;
        	 break;
         }
      }

      // Check on overlapped operation.
      if (fWaitingOnStat)
      {
         // Wait a little while for an event to occur.
         dwRes = WaitForSingleObject(osStatus.hEvent, STATUS_CHECK_TIMEOUT);
         switch(dwRes)
         {
             // Event occurred.
             case WAIT_OBJECT_0:
             {
                 if (!GetOverlappedResult(pReader->u64Handle, &osStatus, &dwOvRes, FALSE))
                 {
                    // An error occurred in the overlapped operation;
                    // call GetLastError to find out what it was
                    // and abort if it is fatal.
                	 DEBUG_PRINTF("GetOverlappedResult FAILED");
                	 fWaitingOnStat = FALSE;
                	 bExitFromThere = TRUE;
                 }
                 else
                 {
                    // Status event is stored in the event flag
                    // specified in the original WaitCommEvent call.
                    // Deal with the status event as appropriate.
/*                	 DEBUG_PRINTF("Serial Event %x", dwCommEvent);

                	 if ( dwCommEvent & EV_BREAK )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_BREAK;\n");
                	 }
                	 if ( dwCommEvent & EV_CTS )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_CTS;\n");
                	 }
                	 if ( dwCommEvent & EV_DSR )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_DSR;\n");
                	 }
                	 if ( dwCommEvent & EV_ERR )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_ERR;\n");
                	 }
                	 if ( dwCommEvent & EV_RING )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_RING;\n");
                	 }
                	 if ( dwCommEvent & EV_RLSD )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_RLSD;\n");
                	 }
                	 if ( dwCommEvent & EV_RXCHAR )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_RXCHAR;\n");
                	 }
                	 if ( dwCommEvent & EV_RXFLAG )
                	 {
                		 DEBUG_PRINTF("Serial Event: EV_RXFLAG;\n");
                	 }
                    //ReportStatusEvent(dwCommEvent);
*/
					 // Set fWaitingOnStat flag to indicate that a new
					 // WaitCommEvent is to be issued.
					 fWaitingOnStat = FALSE;
                     status = CL_OK;
                     bExitFromThere = TRUE;
                 }
                 break;
             }
             case WAIT_TIMEOUT:
             {
                 // Operation isn't complete yet. fWaitingOnStatusHandle flag
                 // isn't changed since I'll loop back around and I don't want
                 // to issue another WaitCommEvent until the first one finishes.
                 //
                 // This is a good time to do some background work.

            	 fWaitingOnStat = TRUE;

                //DoBackgroundWork();
                 break;
             }
             default:
             {
                 // Error in the WaitForSingleObject; abort
                 // This indicates a problem with the OVERLAPPED structure's
                 // event handle.

                //CloseHandle(osStatus.hEvent);
            	 fWaitingOnStat = FALSE;
            	 bExitFromThere = TRUE;
             }
         }
      }
      break;
   };

   CloseHandle(osStatus.hEvent);

   return ( status );
/*   if ( fWaitingOnStat == TRUE )
	   return ( CL_OK );
   else
	   return ( CL_ERROR );*/
}
/******************************************************************************/
/* Name :  e_Result cl_COMAlGetDataWin32( clvoid *pReader, t_Tuple **pptTuple);  */
/* Description : read data from a reader via the COM API. This access be    	*/
/*                shall be provided by the customer and vary depending on     */
/*              target host system OS                                         */
/*              Implements a call which is non blocking or not to allow polling */
/*              on different readers. Only one thread is passing from one reader*/
/*              to the others                                                 */
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : clvoid *pReader : pointer to there reader where to send the data   */
/*                           if NULL, returns PARAMS_ERR                      */
/*        t_Tuple **pptTuple: pointer to tuple list. Allocation is provided  */
/*                            by underlayer. Allocation shall be done using   */
/*                            fnAllocMem to allow library to free it properly */
/*                           if NULL or points to NULL, returns PARAMS_ERR    */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                      */
/*                          * OK                                              */
/*                          * ERROR:   Failure on execution						*/
/*                          * MEM_ERROR : Memory Error (failure, allocation..)*/
/*                          * PARAMS_ERR : Inconsistent parameters            */
/*                          * TIMEOUT_ERR : Timeout when sending data over network */
/*                          * TRANSFER_IN_PROCESS_ERR: a transfer on this     */
/*                          reader is already ongoing                         */
/******************************************************************************/
e_Result cl_COMAlGetDataWin32(  clvoid *ptReader, t_Tuple **pptTuple )
{
	t_clContext *pCtxt 		= CL_NULL;
	e_Result 	status 		= CL_ERROR;
	cl64		cl64Len		= 0 ;
	clu8 		*pData		= CL_NULL;
	cl8			*pMsg			= CL_NULL;
	t_Reader	*pReader	= ptReader;
	DWORD 		dwRead;
	BOOL 		fWaitingOnRead = FALSE;
	OVERLAPPED 	osReader = {0};
	DWORD dwRes;

#define READ_TIMEOUT      500      // milliseconds
#define SERIAL_BUF_SIZE		1024


	/* check incoming parameters */
	if ( pReader == CL_NULL )
		return ( CL_PARAMS_ERR );

	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs == CL_NULL )
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnAllocMem == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnFreeMem == CL_NULL)
		return ( CL_ERROR );

	if ( CL_FAILED( cl_COMAlGetStatus( ptReader ) ) )
	{
		if ( pptTuple != CL_NULL)
		{
			*pptTuple = CL_NULL;
		}
		return ( CL_OK );
	}

	// allocate memory to receive data coming from underlayers
	status = pCtxt->ptHalFuncs->fnAllocMem( ( clvoid **)&pData, SERIAL_BUF_SIZE );	// max size is doubled as we can have short buffers concatenated together.
	if ( CL_FAILED( status ))
    {
        DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR in fnAllocMem\n");
		return ( CL_MEM_ERR );
    }
    if ( pData == CL_NULL )
    {
        DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR pData == CL_NULL\n");
        return ( CL_MEM_ERR );
    }
	// initialize with 0
	memset( pData, 0, SERIAL_BUF_SIZE );


	// get some basic settings
	DCB serialParams = { 0 };
	serialParams.DCBlength = sizeof(serialParams);

	if ( !GetCommState(pReader->u64Handle, &serialParams) )
	{
		DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR in GetCommState\n");
	}

	COMMTIMEOUTS readtimeout = { 0 };
	if ( !GetCommTimeouts( pReader->u64Handle, &readtimeout ) )
	{
		DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR in GetCommTimeouts\n");
	}


	// Create the overlapped event. Must be closed before exiting
	// to avoid a handle leak.
	osReader.hEvent = CreateEvent( CL_NULL, TRUE, FALSE, CL_NULL);

    if ( osReader.hEvent == CL_NULL )// Error creating overlapped event; abort.
	{
        DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR osReader.hEvent == NULL \n");
		status = CL_ERROR;
	}
    else
    {
        if (!fWaitingOnRead)
        {
    //		DEBUG_PRINTF("READ:  Reader handle is %x\n", pReader->u64Handle );
           // Issue read operation.
           if (!ReadFile( (HANDLE) pReader->u64Handle, pData, SERIAL_BUF_SIZE, &dwRead, &osReader))
           {
              if (GetLastError() != ERROR_IO_PENDING)     // read not delayed?
                 // Error in communications; report it.
                  status = CL_ERROR;
              else
              {
                   dwRes = WaitForSingleObject(osReader.hEvent, READ_TIMEOUT);
                   switch(dwRes)
                   {
                      // Read completed.
                      case WAIT_OBJECT_0:
                      {
                          if ( !GetOverlappedResult((HANDLE)pReader->u64Handle, &osReader, &dwRead, FALSE ) )
                              status = CL_ERROR;
                             // Error in communications; report it.
                          else
                          {
								DEBUG_PRINTF("<------ cl_COMAlGetDataWin32: SERIAL received 0x%x [%d]", (int)dwRead, cl_GetElapsedTime()  );
								// Read completed successfully.
								// parse the incoming buffer and prepare the tuple list for upper layer
								// the format of underlaying driver can concatenate several buffers together
								status = cl_HelperNetworkToTuples( pReader, pData, (cl32)dwRead, pptTuple );

								//  Reset flag so that another opertion can be issued.
								fWaitingOnRead = FALSE;

                          }
                          break;
                      }
                      case WAIT_TIMEOUT:
                      {
                          // Operation isn't complete yet. fWaitingOnRead flag isn't
                          // changed since I'll loop back around, and I don't want
                          // to issue another read until the first one finishes.
                          //
                          // This is a good time to do some background work.
                          DEBUG_PRINTF("cl_COMAlGetDataWin32:COM %s Timeout", pReader->tCOMParams.aucPortName );
                          status = CL_OK;
                          break;
                      }
                      default:
                      {
                          status = CL_ERROR;
                          // Error in the WaitForSingleObject; abort.
                          // This indicates a problem with the OVERLAPPED structure's
                          // event handle.
                          break;
                      }
                   }
              }
           }
           else
           {
				DEBUG_PRINTF("<------ cl_COMAlGetDataWin32: SERIAL received completed %x [%d]", (int)dwRead, cl_GetElapsedTime() );
				// read completed immediately

				// parse the incoming buffer and prepare the tuple list for upper layer
				// the format of underlaying driver can concatenate several buffers together
				status = cl_HelperNetworkToTuples( pReader, pData, (cl32)dwRead, pptTuple );
            }
        }
    }

	if ( CL_FAILED( status ) )
	{
		DEBUG_PRINTF("cl_COMAlGetDataWin32: ERROR ReadFile failed with : %x \n", (clu32)dwRes );
	}

	// free unused memory as helper created tuple list and this buffer won't be used in upper layers
	if ( pData != CL_NULL )
		pCtxt->ptHalFuncs->fnFreeMem( (clvoid *)pData );

    // close handle to avoid leaks
    CloseHandle ( osReader.hEvent );

	// exit
	return ( status );
}
/******************************************************************************/
/* Name :  e_Result (cl_COMAlOpenConnectionWin32)( clvoid *pReader );  		*/
/* Description : open a connection to a reader    								*/
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : t_Reader *pReader : pointer to there reader to connect to with ip    */
/*                           address and port			                      */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                     */
/*                          * OK   : connection ok                            */
/*                          * PARAMS_ERR : Inconsistent parameters            */
/*                          * TIMEOUT_ERR : no answer from the reader at this address */
/*							i.e : no reader at all							*/
/******************************************************************************/
e_Result cl_COMAlOpenConnectionWin32( clvoid *ptReader )
{
	t_clContext *pCtxt 		= CL_NULL;
	e_Result status 		= CL_ERROR;
	t_Reader *pReader		= ptReader;
	LPCSTR 	portname 		;
	DWORD  	accessdirection = ( GENERIC_READ | GENERIC_WRITE );
	HANDLE 	hSerial 		= CL_NULL;
	cl8		*pMsg			= CL_NULL;
	cl8		clLocalCOMName[64];
	cl8		Trailer[]		= { 0x5C, 0x5C, 0x2E, 0x5C };	// content of Trailer to get COM access "\\.\" + portname
    DWORD   dwStoredFlags;
	// check params
	if ( pReader == CL_NULL )
		return ( CL_ERROR );

	// get context to have access to function pointers for memory/thread managment on platform
	if ( CL_FAILED(status =  cl_GetContext( &pCtxt )) )
		return ( CL_ERROR );

	// check args
	if ( pCtxt == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnFreeMem == CL_NULL)
		return ( CL_ERROR );

	if ( pCtxt->ptHalFuncs->fnAllocMem == CL_NULL)
		return ( CL_ERROR );

	if ( pReader == CL_NULL )
		return ( CL_ERROR );

	// assign portname
	memset( clLocalCOMName, 0, sizeof( clLocalCOMName ) );
	memcpy( clLocalCOMName, &Trailer[0], sizeof( Trailer) );
	memcpy( &clLocalCOMName[sizeof( Trailer )], pReader->tCOMParams.aucPortName, strlen( pReader->tCOMParams.aucPortName ) );
	portname 		= (LPCSTR)clLocalCOMName;

	// access to com port
	hSerial = CreateFile(
			portname,
			accessdirection,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_OVERLAPPED,
			NULL );

	if (hSerial == INVALID_HANDLE_VALUE)
	{
		errno = GetLastError();

		if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnAllocMem( (clvoid *)&pMsg, 256 )))

/*		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,                 // It´s a system error
		                     NULL,                                      // No string to be formatted needed
		                     errno,                               // Hey Windows: Please explain this error!
		                     MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),  // Do it in the standard language
		                     pMsg,              			// Put the message here
		                     255,             // Number of bytes to store the message
		                     NULL);

		DEBUG_PRINTF("Com %s failed to open with %s \n", pReader->tCOMParams.aucPortName, pMsg );
*/
		// deallocate memory
		pCtxt->ptHalFuncs->fnFreeMem( pMsg );
		status = CL_ERROR;
	}
	else
	{
		pReader->u64Handle = hSerial;

		DEBUG_PRINTF("OPEN: Reader handle is %x", hSerial);
		// Do some basic settings
		DCB serialParams = { 0 };
		serialParams.DCBlength = sizeof(serialParams);

		if ( !GetCommState(pReader->u64Handle, &serialParams) )
		{
			DEBUG_PRINTF("Error in GetCommState");
		}

        switch ( pReader->tCOMParams.eBaudRate )
		{
			case CL_COM_BAUDRATE_4800: serialParams.BaudRate = CBR_4800;break;
			case CL_COM_BAUDRATE_9600: serialParams.BaudRate = CBR_9600;break;
			case CL_COM_BAUDRATE_19200: serialParams.BaudRate = CBR_19200;break;
			case CL_COM_BAUDRATE_38400: serialParams.BaudRate = CBR_38400;break;
			case CL_COM_BAUDRATE_57600: serialParams.BaudRate = CBR_57600;break;
			case CL_COM_BAUDRATE_115200: serialParams.BaudRate = CBR_115200;break;
			default:serialParams.BaudRate = 115200;break;

        }
		switch ( pReader->tCOMParams.eByteSize )
		{
			case CL_COM_BYTESIZE_5BITS : serialParams.ByteSize = DATABITS_5; break;
			case CL_COM_BYTESIZE_6BITS : serialParams.ByteSize = DATABITS_6; break;
			case CL_COM_BYTESIZE_7BITS : serialParams.ByteSize = DATABITS_7; break;
			case CL_COM_BYTESIZE_8BITS : serialParams.ByteSize = DATABITS_8; break;
			default:serialParams.ByteSize = DATABITS_8 ;break;
		}

		switch ( pReader->tCOMParams.eStopBits )
		{
			case CL_COM_STOPBITS_10BIT: serialParams.StopBits = ONESTOPBIT; break;
			case CL_COM_STOPBITS_15BIT: serialParams.StopBits = ONE5STOPBITS; break;
			case CL_COM_STOPBITS_20BIT: serialParams.StopBits = TWOSTOPBITS; break;
			default:serialParams.StopBits = STOPBITS_10; break;
		}

		switch ( pReader->tCOMParams.eParityBits )
		{
			case  CL_COM_PARITYBIT_NONE: serialParams.Parity = NOPARITY; break;
			case  CL_COM_PARITYBIT_ODD: serialParams.Parity = ODDPARITY; break;
			case  CL_COM_PARITYBIT_EVEN: serialParams.Parity = EVENPARITY; break;
			case  CL_COM_PARITYBIT_MARK: serialParams.Parity = MARKPARITY; break;
			case  CL_COM_PARITYBIT_SPACE: serialParams.Parity = SPACEPARITY; break;
			default:serialParams.Parity = PARITY_NONE; break;
		}

		// disable RTS on serial
		serialParams.fRtsControl	= RTS_CONTROL_DISABLE;
		serialParams.fDtrControl	= DTR_CONTROL_DISABLE;

		if ( !SetCommState(pReader->u64Handle, &serialParams) )
		{
			errno = GetLastError();

			if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnAllocMem( (clvoid *)&pMsg, 256 )))

			FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,                 // It�s a system error
			                     NULL,                                      // No string to be formatted needed
			                     errno,                               // Hey Windows: Please explain this error!
			                     MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),  // Do it in the standard language
			                     pMsg,              			// Put the message here
			                     255,             // Number of bytes to store the message
			                     NULL);

			DEBUG_PRINTF("SetCommState %s failed to open with %s \n", pReader->tCOMParams.aucPortName, pMsg );

			// deallocate memory
			pCtxt->ptHalFuncs->fnFreeMem( pMsg );
			status = CL_ERROR;
		}


		// Set timeouts
		COMMTIMEOUTS timeout = { 0 };
		timeout.ReadIntervalTimeout = 50;
		timeout.ReadTotalTimeoutConstant = 50;
		timeout.ReadTotalTimeoutMultiplier = 10;
		timeout.WriteTotalTimeoutConstant = 50;
		timeout.WriteTotalTimeoutMultiplier = 10;
//		timeout.ReadTotalTimeoutConstant = 50;
//		timeout.ReadTotalTimeoutMultiplier = 50;
//		timeout.WriteTotalTimeoutConstant = 50;
//		timeout.WriteTotalTimeoutMultiplier = 10;

		if ( !SetCommTimeouts(pReader->u64Handle, &timeout) )
		{
			{
				errno = GetLastError();

				if ( CL_SUCCESS( pCtxt->ptHalFuncs->fnAllocMem( (clvoid *)&pMsg, 256 )))

				FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,                 // It�s a system error
				                     NULL,                                      // No string to be formatted needed
				                     errno,                               // Hey Windows: Please explain this error!
				                     MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),  // Do it in the standard language
				                     pMsg,              			// Put the message here
				                     255,             // Number of bytes to store the message
				                     NULL);

				DEBUG_PRINTF("SetCommTimeouts %s failed to open with %s \n", pReader->tCOMParams.aucPortName, pMsg );

				// deallocate memory
				pCtxt->ptHalFuncs->fnFreeMem( pMsg );
				status = CL_ERROR;
			}
		}
		COMMTIMEOUTS readtimeout = { 0 };
		GetCommTimeouts( pReader->u64Handle, &readtimeout );

        dwStoredFlags = EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING |\
                       EV_RLSD | EV_RXCHAR | EV_RXFLAG ;

//        dwStoredFlags = EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING |\
//                       EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY ;
        if (!SetCommMask(pReader->u64Handle , dwStoredFlags))
           // error setting communications mask; abort
           return ( CL_ERROR );

		status = CL_OK;

	}

	return ( status );

}
/******************************************************************************/
/* Name :  e_Result (cl_COMAlCloseConnectionWin32)( clvoid * *pReader );  		*/
/* Description : close a connection to a reader    								*/
/*                                                                            */
/******************************************************************************/
/* Parameters:                                                                */
/*  --------------                                                            */
/*  In : t_Reader *pReader : pointer to there reader to close connection    */
/* ---------------                                                            */
/*  Out: none                                                                 */
/* Return value: e_Result                                                     */
/*                          * OK   : connection ok                            */
/*                          * PARAMS_ERR : Inconsistent parameters            */
/******************************************************************************/
e_Result cl_COMAlCloseConnectionWin32( clvoid *ptReader )
{
	t_Reader *pReader = (t_Reader *)ptReader;
	// check params
	if ( !pReader )
		return ( CL_ERROR );

	CloseHandle( pReader->u64Handle );
	return ( CL_OK );
}

/*****************************************************************************/
/* e_Result cl_IPStackSupportLoadWin32( clvoid)								*/
/*																			*/
/* Description : load COM stack support on target OS							*/
/*****************************************************************************/
/* Return Value : 															*/
/*   OK                        :  Result is OK								*/
/*   ERROR,                    : Failure on execution						*/
/****************************************************************************/
e_Result cl_COMStackSupportLoadWin32( clvoid )
{
	DEBUG_PRINTF("cl_COMStackSupportLoadWin32:CL_OK");
	return ( CL_OK );
}
/*****************************************************************************/
/* e_Result cl_IPStackSupportUnloadWin32( clvoid)								*/
/*																			*/
/* Description : unload COM stack support on target OS						*/
/*****************************************************************************/
/* Return Value : 															*/
/*   OK                        :  Result is OK								*/
/*****************************************************************************/
e_Result cl_COMStackSupportUnloadWin32( clvoid )
{
	return ( CL_OK );
}
